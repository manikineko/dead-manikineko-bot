import { logger } from "../../../.robo/build/core/logger.js";
import { options as pluginOptions } from "../../../.robo/build/events/_start.js";
import { waitForTyping } from "../../../.robo/build/events/typingStart/debounce.js";
import { mockInteraction } from "../../../.robo/build/utils/discord-utils.js";
import { client, color } from "robo.js";
import { extractCommandOptions } from "robo.js/utils.js";
/**
 * The core AI interface.
 * Use this to call AI features programatically.
 */ export const AI = {
    chat,
    chatSync,
    generateImage,
    isReady: ()=>_initialized
};
const replying = {};
// How long to wait before processing chat to allow users to add more context
const CHAT_DELAY = 1_000;
export function isReplyingToUser(userId) {
    return !!replying[userId];
}
export let _engine;
let _initialized = false;
export function setEngine(engine) {
    _engine = engine;
}
export function setEngineReady() {
    _initialized = true;
}
async function chat(messages, options) {
    const { channel , member , onReply , showTyping =true  } = options;
    let aiMessages = messages;
    // Add to replying registry
    if (member) {
        let replyingSet = replying[member.user.id];
        if (!replyingSet) {
            replyingSet = new Set();
            replying[member.user.id] = replyingSet;
        }
        replyingSet.add({
            originalMessage: messages[messages.length - 1].content
        });
    }
    // Insert system message if it's not already there
    if (aiMessages[0].role !== 'system' && pluginOptions.systemMessage) {
        aiMessages.unshift({
            role: 'system',
            content: pluginOptions.systemMessage
        });
    }
    let iteration = 0;
    // eslint-disable-next-line no-constant-condition
    while(true){
        aiMessages = await _engine.callHooks('chat', {
            channel,
            member,
            messages: aiMessages
        }, iteration++);
        logger.debug(`Constructed GPT messages:`, aiMessages);
        // Delay for 1 second to let users potentially follow up
        const time = Date.now();
        logger.debug(`Waiting for ${CHAT_DELAY}ms...`);
        await new Promise((resolve)=>setTimeout(resolve, CHAT_DELAY));
        logger.debug(`Done waiting after`, Date.now() - time + 'ms');
        let newMessages = [];
        if (member) {
            // Wait for user to finish typing if they're about to follow up
            newMessages = await waitForTyping(member.user.id);
            if (newMessages.length > 0) {
                logger.debug(`User typed something new!`, newMessages);
            }
            // If user typed something, add it to the messages and recurse
            if (newMessages.length > 0) {
                newMessages.forEach((message)=>{
                    aiMessages.push({
                        role: 'user',
                        content: message
                    });
                });
                continue;
            }
        }
        // Looks like we're ready to reply! Show as typing
        if (showTyping) {
            await channel?.sendTyping();
        }
        const reply = await _engine.chat(aiMessages, {
            ...options,
            threadId: channel?.id,
            userId: member?.user.id
        });
        if (member) {
            // Wait for user to finish typing if they're about to follow up
            newMessages = await waitForTyping(member.user.id);
            if (newMessages.length > 0) {
                logger.debug(`User typed something new!`, newMessages);
            }
            // If user typed something, add it to the messages and recurse
            if (newMessages.length > 0) {
                newMessages.forEach((message)=>{
                    aiMessages.push({
                        role: 'user',
                        content: message
                    });
                });
                continue;
            }
        }
        if (!reply) {
            logger.error(`No response from engine`);
            return;
        }
        // Stream reply before executing function call
        if (typeof reply.message?.content === 'string') {
            // Clean up username prefix if it's there
            let content = reply.message.content;
            const clientUsername = client?.user?.username ?? 'mock';
            if (content.toLowerCase().startsWith(clientUsername.toLowerCase() + ':')) {
                content = content.slice(clientUsername.length + 1).trim();
            }
            await onReply?.({
                text: content
            });
        }
        // Execute a function call if there is one
        if (reply.message?.function_call && reply.finish_reason === 'function_call') {
            const result = await executeFunctionCall(reply.message.function_call, options?.channel, options?.member);
            logger.debug(`Function call result:`, result);
            // If this includes special data such as files or embeds, send them ahead of time
            if (result.reply?.components?.length || result.reply?.files?.length || result.reply?.embeds?.length) {
                logger.debug(`Sending special data ahead of time...`);
                await onReply?.({
                    components: result.reply.components,
                    embeds: result.reply.embeds,
                    files: result.reply.files
                });
            }
            // Add the function result to the messages
            aiMessages.push(reply.message);
            aiMessages.push({
                role: 'function',
                name: reply.message.function_call.name,
                content: JSON.stringify({
                    error: result.error,
                    message: result.reply?.message,
                    success: result.success
                })
            });
            continue;
        }
        break;
    }
    // Remove from replying registry
    if (member) {
        delete replying[member.user.id];
    }
}
async function chatSync(messages, options) {
    return new Promise((resolve)=>{
        chat(messages, {
            ...options,
            onReply: (reply)=>{
                resolve(reply);
            }
        });
    });
}
async function generateImage(options) {
    return _engine.generateImage(options);
}
async function executeFunctionCall(call, channel, member) {
    const gptFunctionHandler = _engine.getFunctionHandlers()[call.name];
    logger.debug(`Executing function call:`, call.name, call.arguments);
    // Validate that the function exists
    if (!gptFunctionHandler) {
        return {
            success: false,
            error: `Don't know how to ${call.name}`
        };
    }
    // Make sure that the function is allowed to be executed in DMs
    if (!gptFunctionHandler.config?.dmPermission && channel?.isDMBased()) {
        return {
            success: false,
            error: `I can't ${call.name} in DMs`
        };
    }
    // Make sure that the user has permission to execute the function
    if (gptFunctionHandler.config?.defaultMemberPermissions) {
        if (!member) {
            return {
                success: false,
                error: `I could not find your member information`
            };
        }
        let defaultMemberPermissions = gptFunctionHandler.config.defaultMemberPermissions;
        if (typeof defaultMemberPermissions !== 'string') {
            defaultMemberPermissions = defaultMemberPermissions + '';
        }
        defaultMemberPermissions = defaultMemberPermissions.replace('n', '');
        const commandPermissions = BigInt(gptFunctionHandler.config.defaultMemberPermissions);
        const memberPermissions = member.permissionsIn(channel);
        if ((memberPermissions.bitfield & commandPermissions) !== commandPermissions) {
            return {
                success: false,
                error: `Member does not have permission to do that`
            };
        }
    }
    // Execute the function
    try {
        const reply = await getCommandReply(gptFunctionHandler, channel, member, call.arguments);
        logger.debug(`Command function reply:`, reply);
        return {
            success: true,
            reply: reply
        };
    } catch (err) {
        logger.debug(color.red(`Error executing AI function:`), err);
        return {
            success: false,
            error: `Error executing function: ${err}`
        };
    }
}
async function getCommandReply(command, channel, member, args) {
    logger.debug(`Executing command:`, command.config, args);
    const { interaction , replyPromise  } = mockInteraction(channel, member, args);
    const commandOptions = extractCommandOptions(interaction, command.config?.options);
    let functionResult = await command.default(interaction, commandOptions);
    // If function result is undefined, wait for the reply content
    if (functionResult === undefined) {
        functionResult = await replyPromise;
    }
    const result = {
        components: [],
        embeds: [],
        files: [],
        message: '',
        text: ''
    };
    if (typeof functionResult === 'string') {
        result.message = functionResult;
        result.text = functionResult;
    } else if (typeof functionResult === 'object') {
        const reply = functionResult;
        const replyEmbeds = reply.embeds;
        result.components = reply.components;
        result.embeds = replyEmbeds;
        result.files = reply.files;
        result.text = reply.content;
        result.message = reply.content || replyEmbeds?.[0]?.title || replyEmbeds?.[0]?.description || '';
    }
    // Describe result if there's no message but there is something
    if (!result.message && result.files?.length) {
        result.message = `The file processing task is complete. (do not include file references in reply)`;
    }
    return result;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL3JvYm8uanMvcm9iby5qcy9wYWNrYWdlcy9wbHVnaW4tYWkvc3JjL2NvcmUvYWkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnQC9jb3JlL2xvZ2dlci5qcydcbmltcG9ydCB7IG9wdGlvbnMgYXMgcGx1Z2luT3B0aW9ucyB9IGZyb20gJ0AvZXZlbnRzL19zdGFydC5qcydcbmltcG9ydCB7IHdhaXRGb3JUeXBpbmcgfSBmcm9tICdAL2V2ZW50cy90eXBpbmdTdGFydC9kZWJvdW5jZS5qcydcbmltcG9ydCB7IG1vY2tJbnRlcmFjdGlvbiB9IGZyb20gJ0AvdXRpbHMvZGlzY29yZC11dGlscy5qcydcbmltcG9ydCB7IENvbW1hbmQsIGNsaWVudCwgY29sb3IgfSBmcm9tICdyb2JvLmpzJ1xuaW1wb3J0IHsgZXh0cmFjdENvbW1hbmRPcHRpb25zIH0gZnJvbSAncm9iby5qcy91dGlscy5qcydcbmltcG9ydCB0eXBlIHtcblx0QmFzZUVuZ2luZSxcblx0Q2hhdEZ1bmN0aW9uQ2FsbCxcblx0Q2hhdE1lc3NhZ2UsXG5cdENoYXRNZXNzYWdlQ29udGVudCxcblx0Q2hhdE9wdGlvbnMgYXMgQmFzZUNoYXRPcHRpb25zLFxuXHRHZW5lcmF0ZUltYWdlT3B0aW9ucyxcblx0R2VuZXJhdGVJbWFnZVJlc3VsdFxufSBmcm9tICdAL2VuZ2luZXMvYmFzZS5qcydcbmltcG9ydCB0eXBlIHtcblx0QVBJRW1iZWQsXG5cdEd1aWxkTWVtYmVyLFxuXHRHdWlsZFRleHRCYXNlZENoYW5uZWwsXG5cdEludGVyYWN0aW9uUmVwbHlPcHRpb25zLFxuXHRUZXh0QmFzZWRDaGFubmVsXG59IGZyb20gJ2Rpc2NvcmQuanMnXG5cbi8qKlxuICogVGhlIGNvcmUgQUkgaW50ZXJmYWNlLlxuICogVXNlIHRoaXMgdG8gY2FsbCBBSSBmZWF0dXJlcyBwcm9ncmFtYXRpY2FsbHkuXG4gKi9cbmV4cG9ydCBjb25zdCBBSSA9IHtcblx0Y2hhdCxcblx0Y2hhdFN5bmMsXG5cdGdlbmVyYXRlSW1hZ2UsXG5cdGlzUmVhZHk6ICgpID0+IF9pbml0aWFsaXplZFxufVxuXG4vLyBLZWVwcyB0cmFjayBvZiB1c2VycyBjdXJyZW50bHkgYmVpbmcgcmVwbGllZCB0b1xuaW50ZXJmYWNlIFVzZXJSZXBseWluZyB7XG5cdG9yaWdpbmFsTWVzc2FnZTogQ2hhdE1lc3NhZ2VDb250ZW50XG59XG5jb25zdCByZXBseWluZzogUmVjb3JkPHN0cmluZywgU2V0PFVzZXJSZXBseWluZz4+ID0ge31cblxuLy8gSG93IGxvbmcgdG8gd2FpdCBiZWZvcmUgcHJvY2Vzc2luZyBjaGF0IHRvIGFsbG93IHVzZXJzIHRvIGFkZCBtb3JlIGNvbnRleHRcbmNvbnN0IENIQVRfREVMQVkgPSAxXzAwMFxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXBseWluZ1RvVXNlcih1c2VySWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gISFyZXBseWluZ1t1c2VySWRdXG59XG5cbmV4cG9ydCBsZXQgX2VuZ2luZTogQmFzZUVuZ2luZVxubGV0IF9pbml0aWFsaXplZCA9IGZhbHNlXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbmdpbmUoZW5naW5lOiBCYXNlRW5naW5lKSB7XG5cdF9lbmdpbmUgPSBlbmdpbmVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEVuZ2luZVJlYWR5KCkge1xuXHRfaW5pdGlhbGl6ZWQgPSB0cnVlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdFJlcGx5IHtcblx0Y29tcG9uZW50cz86IEludGVyYWN0aW9uUmVwbHlPcHRpb25zWydjb21wb25lbnRzJ11cblx0ZW1iZWRzPzogSW50ZXJhY3Rpb25SZXBseU9wdGlvbnNbJ2VtYmVkcyddXG5cdGZpbGVzPzogSW50ZXJhY3Rpb25SZXBseU9wdGlvbnNbJ2ZpbGVzJ11cblx0dGV4dD86IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgQ2hhdE9wdGlvbnMgZXh0ZW5kcyBPbWl0PEJhc2VDaGF0T3B0aW9ucywgJ3RocmVhZElkJyB8ICd1c2VySWQnPiB7XG5cdGNoYW5uZWw/OiBUZXh0QmFzZWRDaGFubmVsIHwgbnVsbFxuXHRtZW1iZXI/OiBHdWlsZE1lbWJlciB8IG51bGxcblx0b25SZXBseTogKHJlcGx5OiBDaGF0UmVwbHkpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNoYXQobWVzc2FnZXM6IENoYXRNZXNzYWdlW10sIG9wdGlvbnM6IENoYXRPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG5cdGNvbnN0IHsgY2hhbm5lbCwgbWVtYmVyLCBvblJlcGx5LCBzaG93VHlwaW5nID0gdHJ1ZSB9ID0gb3B0aW9uc1xuXHRsZXQgYWlNZXNzYWdlcyA9IG1lc3NhZ2VzXG5cblx0Ly8gQWRkIHRvIHJlcGx5aW5nIHJlZ2lzdHJ5XG5cdGlmIChtZW1iZXIpIHtcblx0XHRsZXQgcmVwbHlpbmdTZXQgPSByZXBseWluZ1ttZW1iZXIudXNlci5pZF1cblx0XHRpZiAoIXJlcGx5aW5nU2V0KSB7XG5cdFx0XHRyZXBseWluZ1NldCA9IG5ldyBTZXQoKVxuXHRcdFx0cmVwbHlpbmdbbWVtYmVyLnVzZXIuaWRdID0gcmVwbHlpbmdTZXRcblx0XHR9XG5cdFx0cmVwbHlpbmdTZXQuYWRkKHtcblx0XHRcdG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudFxuXHRcdH0pXG5cdH1cblxuXHQvLyBJbnNlcnQgc3lzdGVtIG1lc3NhZ2UgaWYgaXQncyBub3QgYWxyZWFkeSB0aGVyZVxuXHRpZiAoYWlNZXNzYWdlc1swXS5yb2xlICE9PSAnc3lzdGVtJyAmJiBwbHVnaW5PcHRpb25zLnN5c3RlbU1lc3NhZ2UpIHtcblx0XHRhaU1lc3NhZ2VzLnVuc2hpZnQoe1xuXHRcdFx0cm9sZTogJ3N5c3RlbScsXG5cdFx0XHRjb250ZW50OiBwbHVnaW5PcHRpb25zLnN5c3RlbU1lc3NhZ2Vcblx0XHR9KVxuXHR9XG5cblx0bGV0IGl0ZXJhdGlvbiA9IDBcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0YWlNZXNzYWdlcyA9IGF3YWl0IF9lbmdpbmUuY2FsbEhvb2tzKFxuXHRcdFx0J2NoYXQnLFxuXHRcdFx0e1xuXHRcdFx0XHRjaGFubmVsLFxuXHRcdFx0XHRtZW1iZXIsXG5cdFx0XHRcdG1lc3NhZ2VzOiBhaU1lc3NhZ2VzXG5cdFx0XHR9LFxuXHRcdFx0aXRlcmF0aW9uKytcblx0XHQpXG5cdFx0bG9nZ2VyLmRlYnVnKGBDb25zdHJ1Y3RlZCBHUFQgbWVzc2FnZXM6YCwgYWlNZXNzYWdlcylcblxuXHRcdC8vIERlbGF5IGZvciAxIHNlY29uZCB0byBsZXQgdXNlcnMgcG90ZW50aWFsbHkgZm9sbG93IHVwXG5cdFx0Y29uc3QgdGltZSA9IERhdGUubm93KClcblx0XHRsb2dnZXIuZGVidWcoYFdhaXRpbmcgZm9yICR7Q0hBVF9ERUxBWX1tcy4uLmApXG5cdFx0YXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgQ0hBVF9ERUxBWSkpXG5cdFx0bG9nZ2VyLmRlYnVnKGBEb25lIHdhaXRpbmcgYWZ0ZXJgLCBEYXRlLm5vdygpIC0gdGltZSArICdtcycpXG5cdFx0bGV0IG5ld01lc3NhZ2VzOiBzdHJpbmdbXSA9IFtdXG5cblx0XHRpZiAobWVtYmVyKSB7XG5cdFx0XHQvLyBXYWl0IGZvciB1c2VyIHRvIGZpbmlzaCB0eXBpbmcgaWYgdGhleSdyZSBhYm91dCB0byBmb2xsb3cgdXBcblx0XHRcdG5ld01lc3NhZ2VzID0gYXdhaXQgd2FpdEZvclR5cGluZyhtZW1iZXIudXNlci5pZClcblx0XHRcdGlmIChuZXdNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZyhgVXNlciB0eXBlZCBzb21ldGhpbmcgbmV3IWAsIG5ld01lc3NhZ2VzKVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB1c2VyIHR5cGVkIHNvbWV0aGluZywgYWRkIGl0IHRvIHRoZSBtZXNzYWdlcyBhbmQgcmVjdXJzZVxuXHRcdFx0aWYgKG5ld01lc3NhZ2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0bmV3TWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSkgPT4ge1xuXHRcdFx0XHRcdGFpTWVzc2FnZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRyb2xlOiAndXNlcicsXG5cdFx0XHRcdFx0XHRjb250ZW50OiBtZXNzYWdlXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSlcblx0XHRcdFx0Y29udGludWVcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBMb29rcyBsaWtlIHdlJ3JlIHJlYWR5IHRvIHJlcGx5ISBTaG93IGFzIHR5cGluZ1xuXHRcdGlmIChzaG93VHlwaW5nKSB7XG5cdFx0XHRhd2FpdCBjaGFubmVsPy5zZW5kVHlwaW5nKClcblx0XHR9XG5cblx0XHRjb25zdCByZXBseSA9IGF3YWl0IF9lbmdpbmUuY2hhdChhaU1lc3NhZ2VzLCB7XG5cdFx0XHQuLi5vcHRpb25zLFxuXHRcdFx0dGhyZWFkSWQ6IGNoYW5uZWw/LmlkIGFzIHN0cmluZyxcblx0XHRcdHVzZXJJZDogbWVtYmVyPy51c2VyLmlkIGFzIHN0cmluZ1xuXHRcdH0pXG5cblx0XHRpZiAobWVtYmVyKSB7XG5cdFx0XHQvLyBXYWl0IGZvciB1c2VyIHRvIGZpbmlzaCB0eXBpbmcgaWYgdGhleSdyZSBhYm91dCB0byBmb2xsb3cgdXBcblx0XHRcdG5ld01lc3NhZ2VzID0gYXdhaXQgd2FpdEZvclR5cGluZyhtZW1iZXIudXNlci5pZClcblx0XHRcdGlmIChuZXdNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZyhgVXNlciB0eXBlZCBzb21ldGhpbmcgbmV3IWAsIG5ld01lc3NhZ2VzKVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB1c2VyIHR5cGVkIHNvbWV0aGluZywgYWRkIGl0IHRvIHRoZSBtZXNzYWdlcyBhbmQgcmVjdXJzZVxuXHRcdFx0aWYgKG5ld01lc3NhZ2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0bmV3TWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSkgPT4ge1xuXHRcdFx0XHRcdGFpTWVzc2FnZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRyb2xlOiAndXNlcicsXG5cdFx0XHRcdFx0XHRjb250ZW50OiBtZXNzYWdlXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSlcblx0XHRcdFx0Y29udGludWVcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXJlcGx5KSB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoYE5vIHJlc3BvbnNlIGZyb20gZW5naW5lYClcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdC8vIFN0cmVhbSByZXBseSBiZWZvcmUgZXhlY3V0aW5nIGZ1bmN0aW9uIGNhbGxcblx0XHRpZiAodHlwZW9mIHJlcGx5Lm1lc3NhZ2U/LmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHQvLyBDbGVhbiB1cCB1c2VybmFtZSBwcmVmaXggaWYgaXQncyB0aGVyZVxuXHRcdFx0bGV0IGNvbnRlbnQgPSByZXBseS5tZXNzYWdlLmNvbnRlbnRcblx0XHRcdGNvbnN0IGNsaWVudFVzZXJuYW1lID0gY2xpZW50Py51c2VyPy51c2VybmFtZSA/PyAnbW9jaydcblxuXHRcdFx0aWYgKGNvbnRlbnQudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGNsaWVudFVzZXJuYW1lLnRvTG93ZXJDYXNlKCkgKyAnOicpKSB7XG5cdFx0XHRcdGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKGNsaWVudFVzZXJuYW1lLmxlbmd0aCArIDEpLnRyaW0oKVxuXHRcdFx0fVxuXG5cdFx0XHRhd2FpdCBvblJlcGx5Py4oe1xuXHRcdFx0XHR0ZXh0OiBjb250ZW50XG5cdFx0XHR9KVxuXHRcdH1cblxuXHRcdC8vIEV4ZWN1dGUgYSBmdW5jdGlvbiBjYWxsIGlmIHRoZXJlIGlzIG9uZVxuXHRcdGlmIChyZXBseS5tZXNzYWdlPy5mdW5jdGlvbl9jYWxsICYmIHJlcGx5LmZpbmlzaF9yZWFzb24gPT09ICdmdW5jdGlvbl9jYWxsJykge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZUZ1bmN0aW9uQ2FsbChyZXBseS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwsIG9wdGlvbnM/LmNoYW5uZWwsIG9wdGlvbnM/Lm1lbWJlcilcblx0XHRcdGxvZ2dlci5kZWJ1ZyhgRnVuY3Rpb24gY2FsbCByZXN1bHQ6YCwgcmVzdWx0KVxuXG5cdFx0XHQvLyBJZiB0aGlzIGluY2x1ZGVzIHNwZWNpYWwgZGF0YSBzdWNoIGFzIGZpbGVzIG9yIGVtYmVkcywgc2VuZCB0aGVtIGFoZWFkIG9mIHRpbWVcblx0XHRcdGlmIChyZXN1bHQucmVwbHk/LmNvbXBvbmVudHM/Lmxlbmd0aCB8fCByZXN1bHQucmVwbHk/LmZpbGVzPy5sZW5ndGggfHwgcmVzdWx0LnJlcGx5Py5lbWJlZHM/Lmxlbmd0aCkge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoYFNlbmRpbmcgc3BlY2lhbCBkYXRhIGFoZWFkIG9mIHRpbWUuLi5gKVxuXHRcdFx0XHRhd2FpdCBvblJlcGx5Py4oe1xuXHRcdFx0XHRcdGNvbXBvbmVudHM6IHJlc3VsdC5yZXBseS5jb21wb25lbnRzLFxuXHRcdFx0XHRcdGVtYmVkczogcmVzdWx0LnJlcGx5LmVtYmVkcyxcblx0XHRcdFx0XHRmaWxlczogcmVzdWx0LnJlcGx5LmZpbGVzXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0aGUgZnVuY3Rpb24gcmVzdWx0IHRvIHRoZSBtZXNzYWdlc1xuXHRcdFx0YWlNZXNzYWdlcy5wdXNoKHJlcGx5Lm1lc3NhZ2UpXG5cdFx0XHRhaU1lc3NhZ2VzLnB1c2goe1xuXHRcdFx0XHRyb2xlOiAnZnVuY3Rpb24nLFxuXHRcdFx0XHRuYW1lOiByZXBseS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwubmFtZSxcblx0XHRcdFx0Y29udGVudDogSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0XHRcdGVycm9yOiByZXN1bHQuZXJyb3IsXG5cdFx0XHRcdFx0bWVzc2FnZTogcmVzdWx0LnJlcGx5Py5tZXNzYWdlLFxuXHRcdFx0XHRcdHN1Y2Nlc3M6IHJlc3VsdC5zdWNjZXNzXG5cdFx0XHRcdH0pXG5cdFx0XHR9KVxuXHRcdFx0Y29udGludWVcblx0XHR9XG5cblx0XHRicmVha1xuXHR9XG5cblx0Ly8gUmVtb3ZlIGZyb20gcmVwbHlpbmcgcmVnaXN0cnlcblx0aWYgKG1lbWJlcikge1xuXHRcdGRlbGV0ZSByZXBseWluZ1ttZW1iZXIudXNlci5pZF1cblx0fVxufVxuXG5hc3luYyBmdW5jdGlvbiBjaGF0U3luYyhtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXSwgb3B0aW9uczogT21pdDxDaGF0T3B0aW9ucywgJ29uUmVwbHknPik6IFByb21pc2U8Q2hhdFJlcGx5PiB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdGNoYXQobWVzc2FnZXMsIHtcblx0XHRcdC4uLm9wdGlvbnMsXG5cdFx0XHRvblJlcGx5OiAocmVwbHkpID0+IHtcblx0XHRcdFx0cmVzb2x2ZShyZXBseSlcblx0XHRcdH1cblx0XHR9KVxuXHR9KVxufVxuXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUltYWdlKG9wdGlvbnM6IEdlbmVyYXRlSW1hZ2VPcHRpb25zKTogUHJvbWlzZTxHZW5lcmF0ZUltYWdlUmVzdWx0PiB7XG5cdHJldHVybiBfZW5naW5lLmdlbmVyYXRlSW1hZ2Uob3B0aW9ucylcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUZ1bmN0aW9uQ2FsbChcblx0Y2FsbDogQ2hhdEZ1bmN0aW9uQ2FsbCxcblx0Y2hhbm5lbDogVGV4dEJhc2VkQ2hhbm5lbCB8IG51bGwgfCB1bmRlZmluZWQsXG5cdG1lbWJlcjogR3VpbGRNZW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkXG4pIHtcblx0Y29uc3QgZ3B0RnVuY3Rpb25IYW5kbGVyID0gX2VuZ2luZS5nZXRGdW5jdGlvbkhhbmRsZXJzKClbY2FsbC5uYW1lXVxuXHRsb2dnZXIuZGVidWcoYEV4ZWN1dGluZyBmdW5jdGlvbiBjYWxsOmAsIGNhbGwubmFtZSwgY2FsbC5hcmd1bWVudHMpXG5cblx0Ly8gVmFsaWRhdGUgdGhhdCB0aGUgZnVuY3Rpb24gZXhpc3RzXG5cdGlmICghZ3B0RnVuY3Rpb25IYW5kbGVyKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN1Y2Nlc3M6IGZhbHNlLFxuXHRcdFx0ZXJyb3I6IGBEb24ndCBrbm93IGhvdyB0byAke2NhbGwubmFtZX1gXG5cdFx0fVxuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGZ1bmN0aW9uIGlzIGFsbG93ZWQgdG8gYmUgZXhlY3V0ZWQgaW4gRE1zXG5cdGlmICghZ3B0RnVuY3Rpb25IYW5kbGVyLmNvbmZpZz8uZG1QZXJtaXNzaW9uICYmIGNoYW5uZWw/LmlzRE1CYXNlZCgpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN1Y2Nlc3M6IGZhbHNlLFxuXHRcdFx0ZXJyb3I6IGBJIGNhbid0ICR7Y2FsbC5uYW1lfSBpbiBETXNgXG5cdFx0fVxuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIHVzZXIgaGFzIHBlcm1pc3Npb24gdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb25cblx0aWYgKGdwdEZ1bmN0aW9uSGFuZGxlci5jb25maWc/LmRlZmF1bHRNZW1iZXJQZXJtaXNzaW9ucykge1xuXHRcdGlmICghbWVtYmVyKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdWNjZXNzOiBmYWxzZSxcblx0XHRcdFx0ZXJyb3I6IGBJIGNvdWxkIG5vdCBmaW5kIHlvdXIgbWVtYmVyIGluZm9ybWF0aW9uYFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBkZWZhdWx0TWVtYmVyUGVybWlzc2lvbnMgPSBncHRGdW5jdGlvbkhhbmRsZXIuY29uZmlnLmRlZmF1bHRNZW1iZXJQZXJtaXNzaW9uc1xuXHRcdGlmICh0eXBlb2YgZGVmYXVsdE1lbWJlclBlcm1pc3Npb25zICE9PSAnc3RyaW5nJykge1xuXHRcdFx0ZGVmYXVsdE1lbWJlclBlcm1pc3Npb25zID0gZGVmYXVsdE1lbWJlclBlcm1pc3Npb25zICsgJydcblx0XHR9XG5cdFx0ZGVmYXVsdE1lbWJlclBlcm1pc3Npb25zID0gZGVmYXVsdE1lbWJlclBlcm1pc3Npb25zLnJlcGxhY2UoJ24nLCAnJylcblx0XHRjb25zdCBjb21tYW5kUGVybWlzc2lvbnMgPSBCaWdJbnQoZ3B0RnVuY3Rpb25IYW5kbGVyLmNvbmZpZy5kZWZhdWx0TWVtYmVyUGVybWlzc2lvbnMpXG5cdFx0Y29uc3QgbWVtYmVyUGVybWlzc2lvbnMgPSBtZW1iZXIucGVybWlzc2lvbnNJbihjaGFubmVsIGFzIEd1aWxkVGV4dEJhc2VkQ2hhbm5lbClcblxuXHRcdGlmICgobWVtYmVyUGVybWlzc2lvbnMuYml0ZmllbGQgJiBjb21tYW5kUGVybWlzc2lvbnMpICE9PSBjb21tYW5kUGVybWlzc2lvbnMpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN1Y2Nlc3M6IGZhbHNlLFxuXHRcdFx0XHRlcnJvcjogYE1lbWJlciBkb2VzIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gZG8gdGhhdGBcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBFeGVjdXRlIHRoZSBmdW5jdGlvblxuXHR0cnkge1xuXHRcdGNvbnN0IHJlcGx5ID0gYXdhaXQgZ2V0Q29tbWFuZFJlcGx5KGdwdEZ1bmN0aW9uSGFuZGxlciwgY2hhbm5lbCwgbWVtYmVyLCBjYWxsLmFyZ3VtZW50cylcblx0XHRsb2dnZXIuZGVidWcoYENvbW1hbmQgZnVuY3Rpb24gcmVwbHk6YCwgcmVwbHkpXG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c3VjY2VzczogdHJ1ZSxcblx0XHRcdHJlcGx5OiByZXBseVxuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKGNvbG9yLnJlZChgRXJyb3IgZXhlY3V0aW5nIEFJIGZ1bmN0aW9uOmApLCBlcnIpXG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c3VjY2VzczogZmFsc2UsXG5cdFx0XHRlcnJvcjogYEVycm9yIGV4ZWN1dGluZyBmdW5jdGlvbjogJHtlcnJ9YFxuXHRcdH1cblx0fVxufVxuXG5pbnRlcmZhY2UgQ29tbWFuZFJlcGx5IGV4dGVuZHMgQ2hhdFJlcGx5IHtcblx0bWVzc2FnZTogc3RyaW5nXG59XG5hc3luYyBmdW5jdGlvbiBnZXRDb21tYW5kUmVwbHkoXG5cdGNvbW1hbmQ6IENvbW1hbmQsXG5cdGNoYW5uZWw6IFRleHRCYXNlZENoYW5uZWwgfCBudWxsIHwgdW5kZWZpbmVkLFxuXHRtZW1iZXI6IEd1aWxkTWVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcblx0YXJnczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogUHJvbWlzZTxDb21tYW5kUmVwbHk+IHtcblx0bG9nZ2VyLmRlYnVnKGBFeGVjdXRpbmcgY29tbWFuZDpgLCBjb21tYW5kLmNvbmZpZywgYXJncylcblx0Y29uc3QgeyBpbnRlcmFjdGlvbiwgcmVwbHlQcm9taXNlIH0gPSBtb2NrSW50ZXJhY3Rpb24oY2hhbm5lbCwgbWVtYmVyLCBhcmdzKVxuXHRjb25zdCBjb21tYW5kT3B0aW9ucyA9IGV4dHJhY3RDb21tYW5kT3B0aW9ucyhpbnRlcmFjdGlvbiwgY29tbWFuZC5jb25maWc/Lm9wdGlvbnMpXG5cdGxldCBmdW5jdGlvblJlc3VsdCA9IGF3YWl0IGNvbW1hbmQuZGVmYXVsdChpbnRlcmFjdGlvbiwgY29tbWFuZE9wdGlvbnMpXG5cblx0Ly8gSWYgZnVuY3Rpb24gcmVzdWx0IGlzIHVuZGVmaW5lZCwgd2FpdCBmb3IgdGhlIHJlcGx5IGNvbnRlbnRcblx0aWYgKGZ1bmN0aW9uUmVzdWx0ID09PSB1bmRlZmluZWQpIHtcblx0XHRmdW5jdGlvblJlc3VsdCA9IGF3YWl0IHJlcGx5UHJvbWlzZVxuXHR9XG5cblx0Y29uc3QgcmVzdWx0OiBDb21tYW5kUmVwbHkgPSB7XG5cdFx0Y29tcG9uZW50czogW10sXG5cdFx0ZW1iZWRzOiBbXSxcblx0XHRmaWxlczogW10sXG5cdFx0bWVzc2FnZTogJycsXG5cdFx0dGV4dDogJydcblx0fVxuXHRpZiAodHlwZW9mIGZ1bmN0aW9uUmVzdWx0ID09PSAnc3RyaW5nJykge1xuXHRcdHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb25SZXN1bHRcblx0XHRyZXN1bHQudGV4dCA9IGZ1bmN0aW9uUmVzdWx0XG5cdH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzdWx0ID09PSAnb2JqZWN0Jykge1xuXHRcdGNvbnN0IHJlcGx5ID0gZnVuY3Rpb25SZXN1bHQgYXMgSW50ZXJhY3Rpb25SZXBseU9wdGlvbnNcblx0XHRjb25zdCByZXBseUVtYmVkcyA9IHJlcGx5LmVtYmVkcyBhcyBBUElFbWJlZFtdXG5cblx0XHRyZXN1bHQuY29tcG9uZW50cyA9IHJlcGx5LmNvbXBvbmVudHNcblx0XHRyZXN1bHQuZW1iZWRzID0gcmVwbHlFbWJlZHNcblx0XHRyZXN1bHQuZmlsZXMgPSByZXBseS5maWxlc1xuXHRcdHJlc3VsdC50ZXh0ID0gcmVwbHkuY29udGVudFxuXHRcdHJlc3VsdC5tZXNzYWdlID0gcmVwbHkuY29udGVudCB8fCByZXBseUVtYmVkcz8uWzBdPy50aXRsZSB8fCByZXBseUVtYmVkcz8uWzBdPy5kZXNjcmlwdGlvbiB8fCAnJ1xuXHR9XG5cblx0Ly8gRGVzY3JpYmUgcmVzdWx0IGlmIHRoZXJlJ3Mgbm8gbWVzc2FnZSBidXQgdGhlcmUgaXMgc29tZXRoaW5nXG5cdGlmICghcmVzdWx0Lm1lc3NhZ2UgJiYgcmVzdWx0LmZpbGVzPy5sZW5ndGgpIHtcblx0XHRyZXN1bHQubWVzc2FnZSA9IGBUaGUgZmlsZSBwcm9jZXNzaW5nIHRhc2sgaXMgY29tcGxldGUuIChkbyBub3QgaW5jbHVkZSBmaWxlIHJlZmVyZW5jZXMgaW4gcmVwbHkpYFxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdFxufVxuIl0sIm5hbWVzIjpbImxvZ2dlciIsIm9wdGlvbnMiLCJwbHVnaW5PcHRpb25zIiwid2FpdEZvclR5cGluZyIsIm1vY2tJbnRlcmFjdGlvbiIsImNsaWVudCIsImNvbG9yIiwiZXh0cmFjdENvbW1hbmRPcHRpb25zIiwiQUkiLCJjaGF0IiwiY2hhdFN5bmMiLCJnZW5lcmF0ZUltYWdlIiwiaXNSZWFkeSIsIl9pbml0aWFsaXplZCIsInJlcGx5aW5nIiwiQ0hBVF9ERUxBWSIsImlzUmVwbHlpbmdUb1VzZXIiLCJ1c2VySWQiLCJfZW5naW5lIiwic2V0RW5naW5lIiwiZW5naW5lIiwic2V0RW5naW5lUmVhZHkiLCJtZXNzYWdlcyIsImNoYW5uZWwiLCJtZW1iZXIiLCJvblJlcGx5Iiwic2hvd1R5cGluZyIsImFpTWVzc2FnZXMiLCJyZXBseWluZ1NldCIsInVzZXIiLCJpZCIsIlNldCIsImFkZCIsIm9yaWdpbmFsTWVzc2FnZSIsImxlbmd0aCIsImNvbnRlbnQiLCJyb2xlIiwic3lzdGVtTWVzc2FnZSIsInVuc2hpZnQiLCJpdGVyYXRpb24iLCJjYWxsSG9va3MiLCJkZWJ1ZyIsInRpbWUiLCJEYXRlIiwibm93IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibmV3TWVzc2FnZXMiLCJmb3JFYWNoIiwibWVzc2FnZSIsInB1c2giLCJzZW5kVHlwaW5nIiwicmVwbHkiLCJ0aHJlYWRJZCIsImVycm9yIiwiY2xpZW50VXNlcm5hbWUiLCJ1c2VybmFtZSIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsInNsaWNlIiwidHJpbSIsInRleHQiLCJmdW5jdGlvbl9jYWxsIiwiZmluaXNoX3JlYXNvbiIsInJlc3VsdCIsImV4ZWN1dGVGdW5jdGlvbkNhbGwiLCJjb21wb25lbnRzIiwiZmlsZXMiLCJlbWJlZHMiLCJuYW1lIiwiSlNPTiIsInN0cmluZ2lmeSIsInN1Y2Nlc3MiLCJjYWxsIiwiZ3B0RnVuY3Rpb25IYW5kbGVyIiwiZ2V0RnVuY3Rpb25IYW5kbGVycyIsImFyZ3VtZW50cyIsImNvbmZpZyIsImRtUGVybWlzc2lvbiIsImlzRE1CYXNlZCIsImRlZmF1bHRNZW1iZXJQZXJtaXNzaW9ucyIsInJlcGxhY2UiLCJjb21tYW5kUGVybWlzc2lvbnMiLCJCaWdJbnQiLCJtZW1iZXJQZXJtaXNzaW9ucyIsInBlcm1pc3Npb25zSW4iLCJiaXRmaWVsZCIsImdldENvbW1hbmRSZXBseSIsImVyciIsInJlZCIsImNvbW1hbmQiLCJhcmdzIiwiaW50ZXJhY3Rpb24iLCJyZXBseVByb21pc2UiLCJjb21tYW5kT3B0aW9ucyIsImZ1bmN0aW9uUmVzdWx0IiwiZGVmYXVsdCIsInVuZGVmaW5lZCIsInJlcGx5RW1iZWRzIiwidGl0bGUiLCJkZXNjcmlwdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsTUFBTSxRQUFRLHNDQUFrQjtBQUN6QyxTQUFTQyxXQUFXQyxhQUFhLFFBQVEsd0NBQW9CO0FBQzdELFNBQVNDLGFBQWEsUUFBUSxzREFBa0M7QUFDaEUsU0FBU0MsZUFBZSxRQUFRLDhDQUEwQjtBQUMxRCxTQUFrQkMsTUFBTSxFQUFFQyxLQUFLLFFBQVEsVUFBUztBQUNoRCxTQUFTQyxxQkFBcUIsUUFBUSxtQkFBa0I7QUFrQnhEOzs7Q0FHQyxHQUNELE9BQU8sTUFBTUMsS0FBSztJQUNqQkM7SUFDQUM7SUFDQUM7SUFDQUMsU0FBUyxJQUFNQztBQUNoQixFQUFDO0FBTUQsTUFBTUMsV0FBOEMsQ0FBQztBQUVyRCw2RUFBNkU7QUFDN0UsTUFBTUMsYUFBYTtBQUVuQixPQUFPLFNBQVNDLGlCQUFpQkMsTUFBYyxFQUFXO0lBQ3pELE9BQU8sQ0FBQyxDQUFDSCxRQUFRLENBQUNHLE9BQU87QUFDMUIsQ0FBQztBQUVELE9BQU8sSUFBSUMsUUFBbUI7QUFDOUIsSUFBSUwsZUFBZSxLQUFLO0FBRXhCLE9BQU8sU0FBU00sVUFBVUMsTUFBa0IsRUFBRTtJQUM3Q0YsVUFBVUU7QUFDWCxDQUFDO0FBRUQsT0FBTyxTQUFTQyxpQkFBaUI7SUFDaENSLGVBQWUsSUFBSTtBQUNwQixDQUFDO0FBZUQsZUFBZUosS0FBS2EsUUFBdUIsRUFBRXJCLE9BQW9CLEVBQWlCO0lBQ2pGLE1BQU0sRUFBRXNCLFFBQU8sRUFBRUMsT0FBTSxFQUFFQyxRQUFPLEVBQUVDLFlBQWEsSUFBSSxDQUFBLEVBQUUsR0FBR3pCO0lBQ3hELElBQUkwQixhQUFhTDtJ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