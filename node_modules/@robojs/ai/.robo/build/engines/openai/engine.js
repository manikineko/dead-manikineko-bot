import { _PREFIX, packageJson } from "../../../../.robo/build/core/constants.js";
import { logger } from "../../../../.robo/build/core/logger.js";
import { BaseEngine } from "../../../../.robo/build/engines/base.js";
import { openai } from "../../../../.robo/build/engines/openai/api.js";
import { options as pluginOptions } from "../../../../.robo/build/events/_start.js";
import fs from "node:fs/promises";
import { compare, hasProperties } from "../../../../.robo/build/utils/other-utils.js";
import path from "node:path";
import { readFile } from "node:fs/promises";
import { Flashcore, color, getState, portal, setState } from "robo.js";
const DEFAULT_MODEL = 'gpt-3.5-turbo';
/**
 * AI engine powered by OpenAI.
 * You must have an OpenAI API key in order to use this engine.
 */ export class OpenAiEngine extends BaseEngine {
    /**
	 * Prepares the Assistant instance and optimizes commands for GPT Functions.
	 */ async init() {
        const { functions , functionHandlers  } = await loadFunctions();
        this._gptFunctions = functions;
        this._gptFunctionHandlers = functionHandlers;
        this._assistant = await loadAssistant(functions);
    }
    async chat(messages, options) {
        const { functions =this._gptFunctions , model =pluginOptions?.model ?? DEFAULT_MODEL , temperature =pluginOptions?.temperature , threadId , userId  } = options ?? {};
        const { pollDelay =1_000  } = pluginOptions;
        // Use the assistant if it's available
        if (this._assistant && threadId) {
            // Prepare only the most recent message for the thread
            const mostRecentMessage = messages[messages.length - 1];
            const threadMessage = {
                role: 'user',
                content: mostRecentMessage.content,
                metadata: userId ? {
                    userId
                } : undefined
            };
            // Get the prepared thread data
            const { thread , threadCreated  } = await this._assistant.thread({
                messages,
                threadId,
                threadMessage,
                userId
            });
            // Wait thread runs to complete before continuing
            const activeRun = getState('run', {
                namespace: _PREFIX + '/thread/' + thread.id
            });
            if (activeRun) {
                logger.debug(`Waiting for active run to complete...`);
                await activeRun;
                logger.debug(`Active run completed.`);
            }
            // Add the messages to the thread unless it was just created
            if (!threadCreated) {
                try {
                    await openai.createMessage({
                        ...threadMessage,
                        thread_id: thread.id
                    });
                    logger.debug(`Added message to thread "${color.bold(thread.id)}":`, threadMessage);
                } catch (e) {
                    logger.debug(`Failed to add message to thread "${color.bold(thread.id)}":`, threadMessage);
                    // List most recent runs for this thread
                    const runs = await openai.listRuns({
                        thread_id: thread.id
                    });
                    logger.debug(`Runs for thread "${color.bold(thread.id)}":`, runs);
                    // Cancel any active runs
                    const activeRuns = runs?.data?.filter((run)=>[
                            'in_progress',
                            'requires_action'
                        ].includes(run.status));
                    logger.debug(`Cancelling ${activeRuns?.length} active runs...`);
                    await Promise.all(activeRuns?.map(async (run)=>{
                        await openai.cancelRun({
                            run_id: run.id,
                            thread_id: thread.id
                        });
                        logger.debug(`Cancelled run "${color.bold(run.id)}"`);
                    }) ?? []);
                    await openai.createMessage({
                        ...threadMessage,
                        thread_id: thread.id
                    });
                    logger.debug(`Added message to thread "${color.bold(thread.id)}":`, threadMessage);
                }
            }
            // Run the assistant until we get something back!
            logger.debug(`Running assistant "${color.bold(this._assistant.data.id)}" for OpenAI thread "${color.bold(thread.id)}"`);
            let run = await openai.createRun({
                assistant_id: this._assistant.data.id,
                thread_id: thread.id
            });
            let runResolve = (value)=>value;
            const runPromise = new Promise((resolve)=>{
                runResolve = resolve;
            });
            let response = null;
            setState('run', runPromise, {
                namespace: _PREFIX + '/thread/' + thread.id
            });
            // Wait for the run to complete
            try {
                while([
                    'queued',
                    'in_progress'
                ].includes(run.status)){
                    await new Promise((resolve)=>setTimeout(resolve, pollDelay));
                    run = await openai.getRun({
                        run_id: run.id,
                        thread_id: thread.id
                    });
                    logger.debug(`Run status for "${color.bold(run.id)}":`, run);
                    if (run.status === 'completed') {
                        // TODO: Paginate via "before" cursor + message cache
                        const threadMessages = await openai.getThreadMessages({
                            thread_id: thread.id,
                            limit: 1
                        });
                        response = threadMessages?.data?.[0];
                        return {
                            finish_reason: 'stop',
                            message: {
                                role: response?.role,
                                // @ts-expect-error - // TODO: Abstract this
                                content: response?.content?.[0]?.text?.value
                            }
                        };
                    } else if (run.status === 'failed') {
                        logger.error(`Run failed:`, run);
                        throw new Error(`Run failed: ${run}`);
                    } else if (run.status === 'requires_action') {
                        const functionCall = run.required_action?.submit_tool_outputs.tool_calls[0];
                        if (!functionCall) {
                            throw new Error(`No function call found for ${run.id}`);
                        }
                        return {
                            finish_reason: 'function_call',
                            message: {
                                role: 'assistant',
                                function_call: {
                                    name: functionCall.function.name,
                                    arguments: convertToJSON(functionCall.function.arguments)
                                },
                                content: []
                            }
                        };
                    }
                }
            } finally{
                setState('run', null, {
                    namespace: _PREFIX + '/thread/' + thread.id
                });
                runResolve?.(response);
                logger.debug(`Assistant response:`, response);
            }
        }
        const response = await openai.chat({
            max_tokens: pluginOptions?.maxTokens,
            model: model,
            messages: messages,
            functions: functions,
            temperature: temperature
        });
        logger.debug(`GPT Response:`, response);
        const reply = response?.choices?.[0];
        let replyFunction = undefined;
        if (reply?.message?.function_call) {
            replyFunction = {
                name: reply?.message?.function_call?.name,
                arguments: JSON.parse((reply?.message?.function_call?.arguments) ?? '{}')
            };
        }
        return {
            finish_reason: reply?.finish_reason,
            message: {
                ...reply?.message,
                function_call: replyFunction
            }
        };
    }
    async generateImage(options) {
        const { model ='dall-e-3' , prompt  } = options;
        const response = await openai.createImage({
            model,
            prompt
        });
        logger.debug(`GPT Image Response:`, response);
        return {
            images: response?.data
        };
    }
    getFunctionHandlers() {
        return this._gptFunctionHandlers;
    }
    getInfo() {
        return {
            name: 'OpenAI',
            version: packageJson.version
        };
    }
    constructor(...args){
        super(...args);
        this._gptFunctions = [];
        this._gptFunctionHandlers = {};
    }
}
/**
 * Loads an Assistant instance to be used for certain interactions.
 *
 * @returns The Assistant instance, or null if the feature is disabled.
 */ async function loadAssistant(functions) {
    // No need to load the assistant if Insight feature is disabled
    if (!pluginOptions.insight) {
        logger.debug('Insight is disabled. Skipping assistant initialization.');
        return null;
    }
    // Prepare expected assistant data
    const roboPackageJsonFile = await readFile(path.join(process.cwd(), 'package.json'), 'utf-8');
    const roboPackageJson = JSON.parse(roboPackageJsonFile) ?? {};
    const assistantData = {
        description: roboPackageJson.description ?? '',
        file_ids: [],
        instructions: pluginOptions?.systemMessage ?? '',
        metadata: {
            pluginVersion: packageJson.version,
            roboVersion: roboPackageJson.dependencies?.['robo.js'] ?? 'unknown',
            version: roboPackageJson.version ?? 'unknown'
        },
        model: pluginOptions?.model ?? DEFAULT_MODEL,
        name: roboPackageJson?.name ?? path.basename(process.cwd()),
        tools: []
    };
    // See if we've already created an assistant for this Robo
    let assistant = null;
    const assistantId = await Flashcore.get('assistantId', {
        namespace: _PREFIX
    });
    if (assistantId) {
        assistant = await openai.getAssistant({
            assistant_id: assistantId
        });
        logger.debug(`Found assistant ${color.bold(assistantId)}:`, assistant);
    }
    // Assistant not found via ID? See if it's in the list of assistants in case Flashcore was reset
    if (!assistant) {
        const assistants = await openai.listAssistants();
        assistant = assistants?.find((assistant)=>assistant.data.name === assistantData.name);
        if (assistant) {
            logger.debug(`Found assistant from previous list: ${assistant}`);
        }
    }
    // Still no assistant? Create one!
    if (!assistant) {
        logger.debug(`Creating assistant:`, assistantData);
        assistant = await openai.createAssistant(assistantData);
        logger.info(`Created assistant ${color.bold(assistant.data.id)}`);
    }
    // Set the assistant ID if we didn't already have it
    if (!assistantId) {
        await Flashcore.set('assistantId', assistant.data.id, {
            namespace: _PREFIX
        });
    }
    // Check if the /documents directory has files
    const documentsDir = path.join(process.cwd(), 'documents');
    const documents = [];
    try {
        const documentStats = await fs.stat(documentsDir);
        if (documentStats.isDirectory()) {
            const dirs = await fs.readdir(documentsDir);
            documents.push(...dirs ?? []);
            logger.debug(`Validating documents:`, documents);
            assistantData.tools.push({
                type: 'retrieval'
            });
        }
    } catch (e) {
        if (hasProperties(e, [
            'code'
        ]) && e.code !== 'ENOENT') {
            throw e;
        }
    }
    // Upload documents if they exist
    const documentResults = {};
    await Promise.all(documents.map(async (document)=>{
        try {
            const filePath = path.join(documentsDir, document);
            const fileStats = await fs.stat(filePath);
            // Skip directories
            if (fileStats.isDirectory()) {
                logger.warn(`Directories are not supported. Skipping ${color.bold(document)}`);
                return;
            }
            // Check if the file has already been uploaded and skip if it has
            const cachedFile = await Flashcore.get(document, {
                namespace: _PREFIX + '/files'
            });
            if (cachedFile && cachedFile.bytes === fileStats.size) {
                assistantData.file_ids.push(cachedFile.id);
                logger.debug(`Using cached document ${color.bold(document)}:`, cachedFile);
                return;
            }
            // Upload the file if it doesn't exist
            const fileBlob = new Blob([
                await fs.readFile(filePath, 'utf-8')
            ]);
            const file = await openai.uploadFile({
                purpose: 'assistants',
                file: fileBlob,
                fileName: document
            });
            assistantData.file_ids.push(file.id);
            documentResults[document] = file.id;
            logger.debug(`Uploaded document ${color.bold(document)}:`, file);
            // Cache the file ID for  later use
            await Flashcore.set(document, {
                id: file.id,
                bytes: fileStats.size
            }, {
                namespace: _PREFIX + '/files'
            });
            // Update the list of cached file IDs
            await Flashcore.set('files', (files)=>{
                if (!files) {
                    files = {};
                }
                if (!files[document]) {
                    files[document] = file.id;
                }
                return files;
            }, {
                namespace: _PREFIX
            });
        } catch (e) {
            logger.error(`Error uploading document ${color.bold(document)}:`, e);
        }
    }));
    const uploadedDocuments = Object.keys(documentResults);
    if (uploadedDocuments.length > 0) {
        logger.debug(documentResults);
        logger.info(`Uploaded ${uploadedDocuments.length} documents:`, uploadedDocuments);
    }
    // Got any functions? Add them to the assistant
    functions?.forEach((fun)=>{
        assistantData.tools.push({
            type: 'function',
            function: fun
        });
    });
    // Make sure the assistant is up to date on OpenAI's end
    const differences = compare(assistant.data, assistantData, [
        'description',
        'file_ids',
        'instructions',
        'metadata',
        'model',
        'name',
        'tools'
    ]);
    logger.debug(`Found ${differences.length} assistant differences:`, differences);
    if (differences.length > 0) {
        logger.debug(`Updating assistant ${color.bold(assistant.data.id)} with:`, assistantData);
        assistant = await openai.modifyAssistant({
            assistant_id: assistant.data.id,
            description: assistantData.description,
            file_ids: assistantData.file_ids,
            instructions: assistantData.instructions,
            metadata: assistantData.metadata,
            model: assistantData.model,
            name: assistantData.name,
            retries: 0,
            tools: assistantData.tools
        });
    }
    // Get the list of cached file IDs and make sure they exist
    const cachedFiles = await Flashcore.get('files', {
        namespace: _PREFIX
    }) ?? {};
    const cachedFileNames = Object.keys(cachedFiles);
    logger.debug(`Found ${cachedFileNames.length} cached files:`, cachedFileNames);
    // Remove any cached files that don't exist anymore
    if (cachedFileNames.length > 0) {
        const files = await openai.listFiles();
        const fileNamesToRemove = cachedFileNames.filter((fileName)=>{
            const fileExists = documents?.find((file)=>file === fileName);
            return !fileExists;
        });
        logger.debug(`Removing ${fileNamesToRemove.length} cached files:`, fileNamesToRemove);
        // Only if also in OpenAI's list of files
        const fileIdsToRemove = fileNamesToRemove.map((fileName)=>cachedFiles[fileName]).filter((fileId)=>{
            const fileExists = files?.data?.find((file)=>file.id === fileId);
            return !!fileExists;
        });
        logger.debug(`Removing ${fileIdsToRemove.length} cached file IDs:`, fileIdsToRemove);
        await Promise.all(fileIdsToRemove.map(async (cachedFileId)=>{
            await openai.deleteFile({
                file_id: cachedFileId
            });
            const fileName = Object.keys(cachedFiles).find((fileName)=>cachedFiles[fileName] === cachedFileId);
            if (fileName) {
                await Flashcore.delete(fileName, {
                    namespace: _PREFIX + '/files'
                });
                await Flashcore.set('files', (files)=>{
                    delete files[fileName];
                    return files;
                }, {
                    namespace: _PREFIX
                });
            }
        }));
        logger.debug(`Successfully removed ${fileNamesToRemove.length} cached files.`);
    }
    return assistant;
}
/**
 * Generates an optimized array of GPT functions based on the commands this Robo has available.
 *
 * @returns An object containing the functions and their handlers.
 */ async function loadFunctions() {
    const functions = [];
    const functionHandlers = {};
    // Normalize key to allow formats like "/ai ask", "ai/ask", and "ai ask"
    let whitelistedCommands = Array.isArray(pluginOptions.commands) ? pluginOptions.commands : [];
    whitelistedCommands = whitelistedCommands.map((command)=>{
        let key = command;
        if (key.at(0) === '/') {
            key = key.slice(1);
        }
        key = key.replaceAll('/', ' ');
        return key;
    });
    portal?.commands.filter((command)=>{
        // Only allow commands enabled in the plugin options
        if (Array.isArray(pluginOptions.commands)) {
            return whitelistedCommands.includes(command.key.replaceAll('/', ' '));
        } else {
            return !!pluginOptions.commands;
        }
    }).forEach((command)=>{
        const commandParameters = {
            type: 'object',
            required: [],
            properties: {}
        };
        // Convert Discord command options to GPT function parameters
        commandParameters.properties = command.handler.config?.options?.reduce((properties, option)=>{
            properties[option.name] = {
                type: 'string',
                description: option.description ?? ''
            };
            if (option.required) {
                commandParameters.required?.push(option.name);
            }
            return properties;
        }, {}) ?? {};
        // Add the GPT function to the list
        const functionName = command.key.replaceAll('/', '_');
        functions.push({
            name: functionName,
            description: command.description ?? '',
            parameters: commandParameters
        });
        functionHandlers[functionName] = command.handler;
    });
    logger.debug(`Loaded ${functions.length} GPT functions:`, functions);
    return {
        functions,
        functionHandlers
    };
}
/**
 * Converts a function call to a JSON string like the older API.
 */ function convertToJSON(input) {
    // If the input is already JSON, return it
    try {
        const json = JSON.parse(input);
        logger.debug(`Function call is already JSON:`, json);
        return json;
    } catch  {
    // Do nothing, this is fine
    }
    // Extract the function name and parameters
    const match = input.match(/^(\w+)\((.*)\)$/);
    if (!match) {
        throw new Error('Invalid input format');
    }
    // Split parameters into key-value pairs
    const params = match[2].split(',').map((param)=>param.trim());
    // Construct an object from the key-value pairs
    const result = params.reduce((obj, param)=>{
        const [key, value] = param.split('=').map((p)=>p.trim());
        // Remove leading and trailing single quotes and @ symbol from value
        const formattedValue = value.replace(/^'@?|'$/g, '');
        // Capitalize the first letter of the value if it's not a number
        obj[key] = isNaN(formattedValue) ? formattedValue.charAt(0).toUpperCase() + formattedValue.slice(1) : formattedValue;
        return obj;
    }, {});
    logger.debug(`Converted function call to JSON:`, result);
    // Convert the object to a JSON string
    return result;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL3JvYm8uanMvcm9iby5qcy9wYWNrYWdlcy9wbHVnaW4tYWkvc3JjL2VuZ2luZXMvb3BlbmFpL2VuZ2luZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfUFJFRklYLCBwYWNrYWdlSnNvbiB9IGZyb20gJ0AvY29yZS9jb25zdGFudHMuanMnXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdAL2NvcmUvbG9nZ2VyLmpzJ1xuaW1wb3J0IHsgQmFzZUVuZ2luZSB9IGZyb20gJ0AvZW5naW5lcy9iYXNlLmpzJ1xuaW1wb3J0IHsgQ3JlYXRlVGhyZWFkT3B0aW9ucywgb3BlbmFpIH0gZnJvbSAnQC9lbmdpbmVzL29wZW5haS9hcGkuanMnXG5pbXBvcnQgeyBvcHRpb25zIGFzIHBsdWdpbk9wdGlvbnMgfSBmcm9tICdAL2V2ZW50cy9fc3RhcnQuanMnXG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcy9wcm9taXNlcydcbmltcG9ydCB7IGNvbXBhcmUsIGhhc1Byb3BlcnRpZXMgfSBmcm9tICdAL3V0aWxzL290aGVyLXV0aWxzLmpzJ1xuaW1wb3J0IHBhdGggZnJvbSAnbm9kZTpwYXRoJ1xuaW1wb3J0IHsgcmVhZEZpbGUgfSBmcm9tICdub2RlOmZzL3Byb21pc2VzJ1xuaW1wb3J0IHsgQXNzaXN0YW50IH0gZnJvbSAnQC9lbmdpbmVzL29wZW5haS9hc3Npc3RhbnQuanMnXG5pbXBvcnQgeyBGbGFzaGNvcmUsIGNvbG9yLCBnZXRTdGF0ZSwgcG9ydGFsLCBzZXRTdGF0ZSB9IGZyb20gJ3JvYm8uanMnXG5pbXBvcnQgdHlwZSB7XG5cdENoYXRGdW5jdGlvbixcblx0Q2hhdEZ1bmN0aW9uUGFyYW1ldGVycyxcblx0Q2hhdEZ1bmN0aW9uUHJvcGVydHksXG5cdENoYXRNZXNzYWdlLFxuXHRDaGF0T3B0aW9ucyxcblx0Q2hhdFJlc3VsdCxcblx0R2VuZXJhdGVJbWFnZU9wdGlvbnMsXG5cdEdlbmVyYXRlSW1hZ2VSZXN1bHRcbn0gZnJvbSAnQC9lbmdpbmVzL2Jhc2UuanMnXG5pbXBvcnQgdHlwZSB7IEFzc2lzdGFudERhdGEgfSBmcm9tICdAL2VuZ2luZXMvb3BlbmFpL2Fzc2lzdGFudC5qcydcbmltcG9ydCB0eXBlIHsgRmlsZSwgTWVzc2FnZSB9IGZyb20gJ0AvZW5naW5lcy9vcGVuYWkvdHlwZXMuanMnXG5pbXBvcnQgdHlwZSB7IENvbW1hbmQgfSBmcm9tICdyb2JvLmpzJ1xuXG5jb25zdCBERUZBVUxUX01PREVMID0gJ2dwdC0zLjUtdHVyYm8nXG5cbi8qKlxuICogQUkgZW5naW5lIHBvd2VyZWQgYnkgT3BlbkFJLlxuICogWW91IG11c3QgaGF2ZSBhbiBPcGVuQUkgQVBJIGtleSBpbiBvcmRlciB0byB1c2UgdGhpcyBlbmdpbmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBPcGVuQWlFbmdpbmUgZXh0ZW5kcyBCYXNlRW5naW5lIHtcblx0cHJpdmF0ZSBfYXNzaXN0YW50PzogQXNzaXN0YW50IHwgbnVsbFxuXHRwcml2YXRlIF9ncHRGdW5jdGlvbnM6IENoYXRGdW5jdGlvbltdID0gW11cblx0cHJpdmF0ZSBfZ3B0RnVuY3Rpb25IYW5kbGVyczogUmVjb3JkPHN0cmluZywgQ29tbWFuZD4gPSB7fVxuXG5cdC8qKlxuXHQgKiBQcmVwYXJlcyB0aGUgQXNzaXN0YW50IGluc3RhbmNlIGFuZCBvcHRpbWl6ZXMgY29tbWFuZHMgZm9yIEdQVCBGdW5jdGlvbnMuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgaW5pdCgpIHtcblx0XHRjb25zdCB7IGZ1bmN0aW9ucywgZnVuY3Rpb25IYW5kbGVycyB9ID0gYXdhaXQgbG9hZEZ1bmN0aW9ucygpXG5cdFx0dGhpcy5fZ3B0RnVuY3Rpb25zID0gZnVuY3Rpb25zXG5cdFx0dGhpcy5fZ3B0RnVuY3Rpb25IYW5kbGVycyA9IGZ1bmN0aW9uSGFuZGxlcnNcblx0XHR0aGlzLl9hc3Npc3RhbnQgPSBhd2FpdCBsb2FkQXNzaXN0YW50KGZ1bmN0aW9ucylcblx0fVxuXG5cdHB1YmxpYyBhc3luYyBjaGF0KG1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdLCBvcHRpb25zOiBDaGF0T3B0aW9ucyk6IFByb21pc2U8Q2hhdFJlc3VsdD4ge1xuXHRcdGNvbnN0IHtcblx0XHRcdGZ1bmN0aW9ucyA9IHRoaXMuX2dwdEZ1bmN0aW9ucyxcblx0XHRcdG1vZGVsID0gcGx1Z2luT3B0aW9ucz8ubW9kZWwgPz8gREVGQVVMVF9NT0RFTCxcblx0XHRcdHRlbXBlcmF0dXJlID0gcGx1Z2luT3B0aW9ucz8udGVtcGVyYXR1cmUsXG5cdFx0XHR0aHJlYWRJZCxcblx0XHRcdHVzZXJJZFxuXHRcdH0gPSBvcHRpb25zID8/IHt9XG5cdFx0Y29uc3QgeyBwb2xsRGVsYXkgPSAxXzAwMCB9ID0gcGx1Z2luT3B0aW9uc1xuXG5cdFx0Ly8gVXNlIHRoZSBhc3Npc3RhbnQgaWYgaXQncyBhdmFpbGFibGVcblx0XHRpZiAodGhpcy5fYXNzaXN0YW50ICYmIHRocmVhZElkKSB7XG5cdFx0XHQvLyBQcmVwYXJlIG9ubHkgdGhlIG1vc3QgcmVjZW50IG1lc3NhZ2UgZm9yIHRoZSB0aHJlYWRcblx0XHRcdGNvbnN0IG1vc3RSZWNlbnRNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV1cblx0XHRcdGNvbnN0IHRocmVhZE1lc3NhZ2U6IE5vbk51bGxhYmxlPENyZWF0ZVRocmVhZE9wdGlvbnNbJ21lc3NhZ2VzJ10+W251bWJlcl0gPSB7XG5cdFx0XHRcdHJvbGU6ICd1c2VyJyBhcyBjb25zdCxcblx0XHRcdFx0Y29udGVudDogbW9zdFJlY2VudE1lc3NhZ2UuY29udGVudCBhcyBzdHJpbmcsIC8vIFRPRE86IEFjY291bnQgZm9yIGltYWdlc1xuXHRcdFx0XHRtZXRhZGF0YTogdXNlcklkID8geyB1c2VySWQgfSA6IHVuZGVmaW5lZFxuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZXQgdGhlIHByZXBhcmVkIHRocmVhZCBkYXRhXG5cdFx0XHRjb25zdCB7IHRocmVhZCwgdGhyZWFkQ3JlYXRlZCB9ID0gYXdhaXQgdGhpcy5fYXNzaXN0YW50LnRocmVhZCh7IG1lc3NhZ2VzLCB0aHJlYWRJZCwgdGhyZWFkTWVzc2FnZSwgdXNlcklkIH0pXG5cblx0XHRcdC8vIFdhaXQgdGhyZWFkIHJ1bnMgdG8gY29tcGxldGUgYmVmb3JlIGNvbnRpbnVpbmdcblx0XHRcdGNvbnN0IGFjdGl2ZVJ1biA9IGdldFN0YXRlPFByb21pc2U8dW5rbm93bj4+KCdydW4nLCB7XG5cdFx0XHRcdG5hbWVzcGFjZTogX1BSRUZJWCArICcvdGhyZWFkLycgKyB0aHJlYWQuaWRcblx0XHRcdH0pXG5cdFx0XHRpZiAoYWN0aXZlUnVuKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZyhgV2FpdGluZyBmb3IgYWN0aXZlIHJ1biB0byBjb21wbGV0ZS4uLmApXG5cdFx0XHRcdGF3YWl0IGFjdGl2ZVJ1blxuXHRcdFx0XHRsb2dnZXIuZGVidWcoYEFjdGl2ZSBydW4gY29tcGxldGVkLmApXG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0aGUgbWVzc2FnZXMgdG8gdGhlIHRocmVhZCB1bmxlc3MgaXQgd2FzIGp1c3QgY3JlYXRlZFxuXHRcdFx0aWYgKCF0aHJlYWRDcmVhdGVkKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YXdhaXQgb3BlbmFpLmNyZWF0ZU1lc3NhZ2Uoe1xuXHRcdFx0XHRcdFx0Li4udGhyZWFkTWVzc2FnZSxcblx0XHRcdFx0XHRcdHRocmVhZF9pZDogdGhyZWFkLmlkXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoYEFkZGVkIG1lc3NhZ2UgdG8gdGhyZWFkIFwiJHtjb2xvci5ib2xkKHRocmVhZC5pZCl9XCI6YCwgdGhyZWFkTWVzc2FnZSlcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZyhgRmFpbGVkIHRvIGFkZCBtZXNzYWdlIHRvIHRocmVhZCBcIiR7Y29sb3IuYm9sZCh0aHJlYWQuaWQpfVwiOmAsIHRocmVhZE1lc3NhZ2UpXG5cblx0XHRcdFx0XHQvLyBMaXN0IG1vc3QgcmVjZW50IHJ1bnMgZm9yIHRoaXMgdGhyZWFkXG5cdFx0XHRcdFx0Y29uc3QgcnVucyA9IGF3YWl0IG9wZW5haS5saXN0UnVucyh7XG5cdFx0XHRcdFx0XHR0aHJlYWRfaWQ6IHRocmVhZC5pZFxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKGBSdW5zIGZvciB0aHJlYWQgXCIke2NvbG9yLmJvbGQodGhyZWFkLmlkKX1cIjpgLCBydW5zKVxuXG5cdFx0XHRcdFx0Ly8gQ2FuY2VsIGFueSBhY3RpdmUgcnVuc1xuXHRcdFx0XHRcdGNvbnN0IGFjdGl2ZVJ1bnMgPSBydW5zPy5kYXRhPy5maWx0ZXIoKHJ1bikgPT4gWydpbl9wcm9ncmVzcycsICdyZXF1aXJlc19hY3Rpb24nXS5pbmNsdWRlcyhydW4uc3RhdHVzKSlcblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoYENhbmNlbGxpbmcgJHthY3RpdmVSdW5zPy5sZW5ndGh9IGFjdGl2ZSBydW5zLi4uYClcblxuXHRcdFx0XHRcdGF3YWl0IFByb21pc2UuYWxsKFxuXHRcdFx0XHRcdFx0YWN0aXZlUnVucz8ubWFwKGFzeW5jIChydW4pID0+IHtcblx0XHRcdFx0XHRcdFx0YXdhaXQgb3BlbmFpLmNhbmNlbFJ1bih7XG5cdFx0XHRcdFx0XHRcdFx0cnVuX2lkOiBydW4uaWQsXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkX2lkOiB0aHJlYWQuaWRcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKGBDYW5jZWxsZWQgcnVuIFwiJHtjb2xvci5ib2xkKHJ1bi5pZCl9XCJgKVxuXHRcdFx0XHRcdFx0fSkgPz8gW11cblx0XHRcdFx0XHQpXG5cblx0XHRcdFx0XHRhd2FpdCBvcGVuYWkuY3JlYXRlTWVzc2FnZSh7XG5cdFx0XHRcdFx0XHQuLi50aHJlYWRNZXNzYWdlLFxuXHRcdFx0XHRcdFx0dGhyZWFkX2lkOiB0aHJlYWQuaWRcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZyhgQWRkZWQgbWVzc2FnZSB0byB0aHJlYWQgXCIke2NvbG9yLmJvbGQodGhyZWFkLmlkKX1cIjpgLCB0aHJlYWRNZXNzYWdlKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJ1biB0aGUgYXNzaXN0YW50IHVudGlsIHdlIGdldCBzb21ldGhpbmcgYmFjayFcblx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0YFJ1bm5pbmcgYXNzaXN0YW50IFwiJHtjb2xvci5ib2xkKHRoaXMuX2Fzc2lzdGFudC5kYXRhLmlkKX1cIiBmb3IgT3BlbkFJIHRocmVhZCBcIiR7Y29sb3IuYm9sZCh0aHJlYWQuaWQpfVwiYFxuXHRcdFx0KVxuXHRcdFx0bGV0IHJ1biA9IGF3YWl0IG9wZW5haS5jcmVhdGVSdW4oe1xuXHRcdFx0XHRhc3Npc3RhbnRfaWQ6IHRoaXMuX2Fzc2lzdGFudC5kYXRhLmlkLFxuXHRcdFx0XHR0aHJlYWRfaWQ6IHRocmVhZC5pZFxuXHRcdFx0fSlcblx0XHRcdGxldCBydW5SZXNvbHZlID0gKHZhbHVlOiB1bmtub3duKSA9PiB2YWx1ZVxuXHRcdFx0Y29uc3QgcnVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdFx0XHRcdHJ1blJlc29sdmUgPSByZXNvbHZlXG5cdFx0XHR9KVxuXHRcdFx0bGV0IHJlc3BvbnNlOiBNZXNzYWdlIHwgbnVsbCA9IG51bGxcblx0XHRcdHNldFN0YXRlKCdydW4nLCBydW5Qcm9taXNlLCB7XG5cdFx0XHRcdG5hbWVzcGFjZTogX1BSRUZJWCArICcvdGhyZWFkLycgKyB0aHJlYWQuaWRcblx0XHRcdH0pXG5cblx0XHRcdC8vIFdhaXQgZm9yIHRoZSBydW4gdG8gY29tcGxldGVcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdoaWxlIChbJ3F1ZXVlZCcsICdpbl9wcm9ncmVzcyddLmluY2x1ZGVzKHJ1bi5zdGF0dXMpKSB7XG5cdFx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcG9sbERlbGF5KSlcblx0XHRcdFx0XHRydW4gPSBhd2FpdCBvcGVuYWkuZ2V0UnVuKHtcblx0XHRcdFx0XHRcdHJ1bl9pZDogcnVuLmlkLFxuXHRcdFx0XHRcdFx0dGhyZWFkX2lkOiB0aHJlYWQuaWRcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZyhgUnVuIHN0YXR1cyBmb3IgXCIke2NvbG9yLmJvbGQocnVuLmlkKX1cIjpgLCBydW4pXG5cblx0XHRcdFx0XHRpZiAocnVuLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcblx0XHRcdFx0XHRcdC8vIFRPRE86IFBhZ2luYXRlIHZpYSBcImJlZm9yZVwiIGN1cnNvciArIG1lc3NhZ2UgY2FjaGVcblx0XHRcdFx0XHRcdGNvbnN0IHRocmVhZE1lc3NhZ2VzID0gYXdhaXQgb3BlbmFpLmdldFRocmVhZE1lc3NhZ2VzKHtcblx0XHRcdFx0XHRcdFx0dGhyZWFkX2lkOiB0aHJlYWQuaWQsXG5cdFx0XHRcdFx0XHRcdGxpbWl0OiAxXG5cdFx0XHRcdFx0XHR9KVxuXG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IHRocmVhZE1lc3NhZ2VzPy5kYXRhPy5bMF1cblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdGZpbmlzaF9yZWFzb246ICdzdG9wJywgLy8gVE9ETzogQWJzdHJhY3QgdGhpc1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cm9sZTogcmVzcG9uc2U/LnJvbGUsXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciAtIC8vIFRPRE86IEFic3RyYWN0IHRoaXNcblx0XHRcdFx0XHRcdFx0XHRjb250ZW50OiByZXNwb25zZT8uY29udGVudD8uWzBdPy50ZXh0Py52YWx1ZVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChydW4uc3RhdHVzID09PSAnZmFpbGVkJykge1xuXHRcdFx0XHRcdFx0bG9nZ2VyLmVycm9yKGBSdW4gZmFpbGVkOmAsIHJ1bilcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgUnVuIGZhaWxlZDogJHtydW59YClcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJ1bi5zdGF0dXMgPT09ICdyZXF1aXJlc19hY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBmdW5jdGlvbkNhbGwgPSBydW4ucmVxdWlyZWRfYWN0aW9uPy5zdWJtaXRfdG9vbF9vdXRwdXRzLnRvb2xfY2FsbHNbMF1cblx0XHRcdFx0XHRcdGlmICghZnVuY3Rpb25DYWxsKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgTm8gZnVuY3Rpb24gY2FsbCBmb3VuZCBmb3IgJHtydW4uaWR9YClcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0ZmluaXNoX3JlYXNvbjogJ2Z1bmN0aW9uX2NhbGwnLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cm9sZTogJ2Fzc2lzdGFudCcsXG5cdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb25fY2FsbDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZTogZnVuY3Rpb25DYWxsLmZ1bmN0aW9uLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRhcmd1bWVudHM6IGNvbnZlcnRUb0pTT04oZnVuY3Rpb25DYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cylcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGNvbnRlbnQ6IFtdXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHNldFN0YXRlKCdydW4nLCBudWxsLCB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlOiBfUFJFRklYICsgJy90aHJlYWQvJyArIHRocmVhZC5pZFxuXHRcdFx0XHR9KVxuXHRcdFx0XHRydW5SZXNvbHZlPy4ocmVzcG9uc2UpXG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZyhgQXNzaXN0YW50IHJlc3BvbnNlOmAsIHJlc3BvbnNlKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQoe1xuXHRcdFx0bWF4X3Rva2VuczogcGx1Z2luT3B0aW9ucz8ubWF4VG9rZW5zLFxuXHRcdFx0bW9kZWw6IG1vZGVsLFxuXHRcdFx0bWVzc2FnZXM6IG1lc3NhZ2VzLFxuXHRcdFx0ZnVuY3Rpb25zOiBmdW5jdGlvbnMsXG5cdFx0XHR0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmVcblx0XHR9KVxuXHRcdGxvZ2dlci5kZWJ1ZyhgR1BUIFJlc3BvbnNlOmAsIHJlc3BvbnNlKVxuXG5cdFx0Y29uc3QgcmVwbHkgPSByZXNwb25zZT8uY2hvaWNlcz8uWzBdXG5cdFx0bGV0IHJlcGx5RnVuY3Rpb24gPSB1bmRlZmluZWRcblx0XHRpZiAocmVwbHk/Lm1lc3NhZ2U/LmZ1bmN0aW9uX2NhbGwpIHtcblx0XHRcdHJlcGx5RnVuY3Rpb24gPSB7XG5cdFx0XHRcdG5hbWU6IHJlcGx5Py5tZXNzYWdlPy5mdW5jdGlvbl9jYWxsPy5uYW1lLFxuXHRcdFx0XHRhcmd1bWVudHM6IEpTT04ucGFyc2UoKHJlcGx5Py5tZXNzYWdlPy5mdW5jdGlvbl9jYWxsPy5hcmd1bWVudHMgYXMgdW5rbm93biBhcyBzdHJpbmcpID8/ICd7fScpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRmaW5pc2hfcmVhc29uOiByZXBseT8uZmluaXNoX3JlYXNvbixcblx0XHRcdG1lc3NhZ2U6IHtcblx0XHRcdFx0Li4ucmVwbHk/Lm1lc3NhZ2UsXG5cdFx0XHRcdGZ1bmN0aW9uX2NhbGw6IHJlcGx5RnVuY3Rpb25cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgZ2VuZXJhdGVJbWFnZShvcHRpb25zOiBHZW5lcmF0ZUltYWdlT3B0aW9ucyk6IFByb21pc2U8R2VuZXJhdGVJbWFnZVJlc3VsdD4ge1xuXHRcdGNvbnN0IHsgbW9kZWwgPSAnZGFsbC1lLTMnLCBwcm9tcHQgfSA9IG9wdGlvbnNcblxuXHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNyZWF0ZUltYWdlKHtcblx0XHRcdG1vZGVsLFxuXHRcdFx0cHJvbXB0XG5cdFx0fSlcblx0XHRsb2dnZXIuZGVidWcoYEdQVCBJbWFnZSBSZXNwb25zZTpgLCByZXNwb25zZSlcblxuXHRcdHJldHVybiB7XG5cdFx0XHRpbWFnZXM6IHJlc3BvbnNlPy5kYXRhXG5cdFx0fVxuXHR9XG5cblx0cHVibGljIGdldEZ1bmN0aW9uSGFuZGxlcnMoKTogUmVjb3JkPHN0cmluZywgQ29tbWFuZD4ge1xuXHRcdHJldHVybiB0aGlzLl9ncHRGdW5jdGlvbkhhbmRsZXJzXG5cdH1cblxuXHRwdWJsaWMgZ2V0SW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogJ09wZW5BSScsXG5cdFx0XHR2ZXJzaW9uOiBwYWNrYWdlSnNvbi52ZXJzaW9uXG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogTG9hZHMgYW4gQXNzaXN0YW50IGluc3RhbmNlIHRvIGJlIHVzZWQgZm9yIGNlcnRhaW4gaW50ZXJhY3Rpb25zLlxuICpcbiAqIEByZXR1cm5zIFRoZSBBc3Npc3RhbnQgaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRBc3Npc3RhbnQoZnVuY3Rpb25zPzogQ2hhdEZ1bmN0aW9uW10pOiBQcm9taXNlPEFzc2lzdGFudCB8IG51bGwgfCB1bmRlZmluZWQ+IHtcblx0Ly8gTm8gbmVlZCB0byBsb2FkIHRoZSBhc3Npc3RhbnQgaWYgSW5zaWdodCBmZWF0dXJlIGlzIGRpc2FibGVkXG5cdGlmICghcGx1Z2luT3B0aW9ucy5pbnNpZ2h0KSB7XG5cdFx0bG9nZ2VyLmRlYnVnKCdJbnNpZ2h0IGlzIGRpc2FibGVkLiBTa2lwcGluZyBhc3Npc3RhbnQgaW5pdGlhbGl6YXRpb24uJylcblx0XHRyZXR1cm4gbnVsbFxuXHR9XG5cblx0Ly8gUHJlcGFyZSBleHBlY3RlZCBhc3Npc3RhbnQgZGF0YVxuXHRjb25zdCByb2JvUGFja2FnZUpzb25GaWxlID0gYXdhaXQgcmVhZEZpbGUocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwYWNrYWdlLmpzb24nKSwgJ3V0Zi04Jylcblx0Y29uc3Qgcm9ib1BhY2thZ2VKc29uID0gSlNPTi5wYXJzZShyb2JvUGFja2FnZUpzb25GaWxlKSA/PyB7fVxuXHRjb25zdCBhc3Npc3RhbnREYXRhOiBPbWl0PEFzc2lzdGFudERhdGEsICdjcmVhdGVkX2F0JyB8ICdpZCcgfCAnb2JqZWN0Jz4gPSB7XG5cdFx0ZGVzY3JpcHRpb246IHJvYm9QYWNrYWdlSnNvbi5kZXNjcmlwdGlvbiA/PyAnJyxcblx0XHRmaWxlX2lkczogW10sXG5cdFx0aW5zdHJ1Y3Rpb25zOiBwbHVnaW5PcHRpb25zPy5zeXN0ZW1NZXNzYWdlID8/ICcnLFxuXHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRwbHVnaW5WZXJzaW9uOiBwYWNrYWdlSnNvbi52ZXJzaW9uLFxuXHRcdFx0cm9ib1ZlcnNpb246IHJvYm9QYWNrYWdlSnNvbi5kZXBlbmRlbmNpZXM/Llsncm9iby5qcyddID8/ICd1bmtub3duJyxcblx0XHRcdHZlcnNpb246IHJvYm9QYWNrYWdlSnNvbi52ZXJzaW9uID8/ICd1bmtub3duJ1xuXHRcdH0sXG5cdFx0bW9kZWw6IHBsdWdpbk9wdGlvbnM/Lm1vZGVsID8/IERFRkFVTFRfTU9ERUwsXG5cdFx0bmFtZTogcm9ib1BhY2thZ2VKc29uPy5uYW1lID8/IHBhdGguYmFzZW5hbWUocHJvY2Vzcy5jd2QoKSksXG5cdFx0dG9vbHM6IFtdXG5cdH1cblxuXHQvLyBTZWUgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGFuIGFzc2lzdGFudCBmb3IgdGhpcyBSb2JvXG5cdGxldCBhc3Npc3RhbnQ6IEFzc2lzdGFudCB8IHVuZGVmaW5lZCB8IG51bGwgPSBudWxsXG5cdGNvbnN0IGFzc2lzdGFudElkID0gYXdhaXQgRmxhc2hjb3JlLmdldDxzdHJpbmc+KCdhc3Npc3RhbnRJZCcsIHtcblx0XHRuYW1lc3BhY2U6IF9QUkVGSVhcblx0fSlcblx0aWYgKGFzc2lzdGFudElkKSB7XG5cdFx0YXNzaXN0YW50ID0gYXdhaXQgb3BlbmFpLmdldEFzc2lzdGFudCh7IGFzc2lzdGFudF9pZDogYXNzaXN0YW50SWQgfSlcblx0XHRsb2dnZXIuZGVidWcoYEZvdW5kIGFzc2lzdGFudCAke2NvbG9yLmJvbGQoYXNzaXN0YW50SWQpfTpgLCBhc3Npc3RhbnQpXG5cdH1cblxuXHQvLyBBc3Npc3RhbnQgbm90IGZvdW5kIHZpYSBJRD8gU2VlIGlmIGl0J3MgaW4gdGhlIGxpc3Qgb2YgYXNzaXN0YW50cyBpbiBjYXNlIEZsYXNoY29yZSB3YXMgcmVzZXRcblx0aWYgKCFhc3Npc3RhbnQpIHtcblx0XHRjb25zdCBhc3Npc3RhbnRzID0gYXdhaXQgb3BlbmFpLmxpc3RBc3Npc3RhbnRzKClcblx0XHRhc3Npc3RhbnQgPSBhc3Npc3RhbnRzPy5maW5kKChhc3Npc3RhbnQpID0+IGFzc2lzdGFudC5kYXRhLm5hbWUgPT09IGFzc2lzdGFudERhdGEubmFtZSlcblxuXHRcdGlmIChhc3Npc3RhbnQpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZyhgRm91bmQgYXNzaXN0YW50IGZyb20gcHJldmlvdXMgbGlzdDogJHthc3Npc3RhbnR9YClcblx0XHR9XG5cdH1cblxuXHQvLyBTdGlsbCBubyBhc3Npc3RhbnQ/IENyZWF0ZSBvbmUhXG5cdGlmICghYXNzaXN0YW50KSB7XG5cdFx0bG9nZ2VyLmRlYnVnKGBDcmVhdGluZyBhc3Npc3RhbnQ6YCwgYXNzaXN0YW50RGF0YSlcblx0XHRhc3Npc3RhbnQgPSBhd2FpdCBvcGVuYWkuY3JlYXRlQXNzaXN0YW50KGFzc2lzdGFudERhdGEpXG5cdFx0bG9nZ2VyLmluZm8oYENyZWF0ZWQgYXNzaXN0YW50ICR7Y29sb3IuYm9sZChhc3Npc3RhbnQuZGF0YS5pZCl9YClcblx0fVxuXG5cdC8vIFNldCB0aGUgYXNzaXN0YW50IElEIGlmIHdlIGRpZG4ndCBhbHJlYWR5IGhhdmUgaXRcblx0aWYgKCFhc3Npc3RhbnRJZCkge1xuXHRcdGF3YWl0IEZsYXNoY29yZS5zZXQoJ2Fzc2lzdGFudElkJywgYXNzaXN0YW50LmRhdGEuaWQsIHtcblx0XHRcdG5hbWVzcGFjZTogX1BSRUZJWFxuXHRcdH0pXG5cdH1cblxuXHQvLyBDaGVjayBpZiB0aGUgL2RvY3VtZW50cyBkaXJlY3RvcnkgaGFzIGZpbGVzXG5cdGNvbnN0IGRvY3VtZW50c0RpciA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnZG9jdW1lbnRzJylcblx0Y29uc3QgZG9jdW1lbnRzOiBzdHJpbmdbXSA9IFtdXG5cblx0dHJ5IHtcblx0XHRjb25zdCBkb2N1bWVudFN0YXRzID0gYXdhaXQgZnMuc3RhdChkb2N1bWVudHNEaXIpXG5cdFx0aWYgKGRvY3VtZW50U3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuXHRcdFx0Y29uc3QgZGlycyA9IGF3YWl0IGZzLnJlYWRkaXIoZG9jdW1lbnRzRGlyKVxuXHRcdFx0ZG9jdW1lbnRzLnB1c2goLi4uKGRpcnMgPz8gW10pKVxuXHRcdFx0bG9nZ2VyLmRlYnVnKGBWYWxpZGF0aW5nIGRvY3VtZW50czpgLCBkb2N1bWVudHMpXG5cblx0XHRcdGFzc2lzdGFudERhdGEudG9vbHMucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICdyZXRyaWV2YWwnXG5cdFx0XHR9KVxuXHRcdH1cblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmIChoYXNQcm9wZXJ0aWVzPHsgY29kZTogdW5rbm93biB9PihlLCBbJ2NvZGUnXSkgJiYgZS5jb2RlICE9PSAnRU5PRU5UJykge1xuXHRcdFx0dGhyb3cgZVxuXHRcdH1cblx0fVxuXG5cdC8vIFVwbG9hZCBkb2N1bWVudHMgaWYgdGhleSBleGlzdFxuXHRjb25zdCBkb2N1bWVudFJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuXHRhd2FpdCBQcm9taXNlLmFsbChcblx0XHRkb2N1bWVudHMubWFwKGFzeW5jIChkb2N1bWVudCkgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4oZG9jdW1lbnRzRGlyLCBkb2N1bWVudClcblx0XHRcdFx0Y29uc3QgZmlsZVN0YXRzID0gYXdhaXQgZnMuc3RhdChmaWxlUGF0aClcblxuXHRcdFx0XHQvLyBTa2lwIGRpcmVjdG9yaWVzXG5cdFx0XHRcdGlmIChmaWxlU3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuXHRcdFx0XHRcdGxvZ2dlci53YXJuKGBEaXJlY3RvcmllcyBhcmUgbm90IHN1cHBvcnRlZC4gU2tpcHBpbmcgJHtjb2xvci5ib2xkKGRvY3VtZW50KX1gKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIGZpbGUgaGFzIGFscmVhZHkgYmVlbiB1cGxvYWRlZCBhbmQgc2tpcCBpZiBpdCBoYXNcblx0XHRcdFx0Y29uc3QgY2FjaGVkRmlsZSA9IGF3YWl0IEZsYXNoY29yZS5nZXQ8RmlsZT4oZG9jdW1lbnQsIHtcblx0XHRcdFx0XHRuYW1lc3BhY2U6IF9QUkVGSVggKyAnL2ZpbGVzJ1xuXHRcdFx0XHR9KVxuXG5cdFx0XHRcdGlmIChjYWNoZWRGaWxlICYmIGNhY2hlZEZpbGUuYnl0ZXMgPT09IGZpbGVTdGF0cy5zaXplKSB7XG5cdFx0XHRcdFx0YXNzaXN0YW50RGF0YS5maWxlX2lkcy5wdXNoKGNhY2hlZEZpbGUuaWQpXG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKGBVc2luZyBjYWNoZWQgZG9jdW1lbnQgJHtjb2xvci5ib2xkKGRvY3VtZW50KX06YCwgY2FjaGVkRmlsZSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVwbG9hZCB0aGUgZmlsZSBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cdFx0XHRcdGNvbnN0IGZpbGVCbG9iID0gbmV3IEJsb2IoW2F3YWl0IGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKV0pXG5cdFx0XHRcdGNvbnN0IGZpbGUgPSBhd2FpdCBvcGVuYWkudXBsb2FkRmlsZSh7XG5cdFx0XHRcdFx0cHVycG9zZTogJ2Fzc2lzdGFudHMnLFxuXHRcdFx0XHRcdGZpbGU6IGZpbGVCbG9iLFxuXHRcdFx0XHRcdGZpbGVOYW1lOiBkb2N1bWVudFxuXHRcdFx0XHR9KVxuXHRcdFx0XHRhc3Npc3RhbnREYXRhLmZpbGVfaWRzLnB1c2goZmlsZS5pZClcblx0XHRcdFx0ZG9jdW1lbnRSZXN1bHRzW2RvY3VtZW50XSA9IGZpbGUuaWRcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKGBVcGxvYWRlZCBkb2N1bWVudCAke2NvbG9yLmJvbGQoZG9jdW1lbnQpfTpgLCBmaWxlKVxuXG5cdFx0XHRcdC8vIENhY2hlIHRoZSBmaWxlIElEIGZvciAgbGF0ZXIgdXNlXG5cdFx0XHRcdGF3YWl0IEZsYXNoY29yZS5zZXQ8RmlsZT4oXG5cdFx0XHRcdFx0ZG9jdW1lbnQsXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWQ6IGZpbGUuaWQsXG5cdFx0XHRcdFx0XHRieXRlczogZmlsZVN0YXRzLnNpemVcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdG5hbWVzcGFjZTogX1BSRUZJWCArICcvZmlsZXMnXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBsaXN0IG9mIGNhY2hlZCBmaWxlIElEc1xuXHRcdFx0XHRhd2FpdCBGbGFzaGNvcmUuc2V0KFxuXHRcdFx0XHRcdCdmaWxlcycsXG5cdFx0XHRcdFx0KGZpbGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIWZpbGVzKSB7XG5cdFx0XHRcdFx0XHRcdGZpbGVzID0ge31cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghZmlsZXNbZG9jdW1lbnRdKSB7XG5cdFx0XHRcdFx0XHRcdGZpbGVzW2RvY3VtZW50XSA9IGZpbGUuaWRcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGZpbGVzXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRuYW1lc3BhY2U6IF9QUkVGSVhcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKGBFcnJvciB1cGxvYWRpbmcgZG9jdW1lbnQgJHtjb2xvci5ib2xkKGRvY3VtZW50KX06YCwgZSlcblx0XHRcdH1cblx0XHR9KVxuXHQpXG5cblx0Y29uc3QgdXBsb2FkZWREb2N1bWVudHMgPSBPYmplY3Qua2V5cyhkb2N1bWVudFJlc3VsdHMpXG5cdGlmICh1cGxvYWRlZERvY3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKGRvY3VtZW50UmVzdWx0cylcblx0XHRsb2dnZXIuaW5mbyhgVXBsb2FkZWQgJHt1cGxvYWRlZERvY3VtZW50cy5sZW5ndGh9IGRvY3VtZW50czpgLCB1cGxvYWRlZERvY3VtZW50cylcblx0fVxuXG5cdC8vIEdvdCBhbnkgZnVuY3Rpb25zPyBBZGQgdGhlbSB0byB0aGUgYXNzaXN0YW50XG5cdGZ1bmN0aW9ucz8uZm9yRWFjaCgoZnVuKSA9PiB7XG5cdFx0YXNzaXN0YW50RGF0YS50b29scy5wdXNoKHtcblx0XHRcdHR5cGU6ICdmdW5jdGlvbicsXG5cdFx0XHRmdW5jdGlvbjogZnVuXG5cdFx0fSlcblx0fSlcblxuXHQvLyBNYWtlIHN1cmUgdGhlIGFzc2lzdGFudCBpcyB1cCB0byBkYXRlIG9uIE9wZW5BSSdzIGVuZFxuXHRjb25zdCBkaWZmZXJlbmNlcyA9IGNvbXBhcmUoYXNzaXN0YW50LmRhdGEgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgYXNzaXN0YW50RGF0YSwgW1xuXHRcdCdkZXNjcmlwdGlvbicsXG5cdFx0J2ZpbGVfaWRzJyxcblx0XHQnaW5zdHJ1Y3Rpb25zJyxcblx0XHQnbWV0YWRhdGEnLFxuXHRcdCdtb2RlbCcsXG5cdFx0J25hbWUnLFxuXHRcdCd0b29scydcblx0XSlcblx0bG9nZ2VyLmRlYnVnKGBGb3VuZCAke2RpZmZlcmVuY2VzLmxlbmd0aH0gYXNzaXN0YW50IGRpZmZlcmVuY2VzOmAsIGRpZmZlcmVuY2VzKVxuXHRpZiAoZGlmZmVyZW5jZXMubGVuZ3RoID4gMCkge1xuXHRcdGxvZ2dlci5kZWJ1ZyhgVXBkYXRpbmcgYXNzaXN0YW50ICR7Y29sb3IuYm9sZChhc3Npc3RhbnQuZGF0YS5pZCl9IHdpdGg6YCwgYXNzaXN0YW50RGF0YSlcblx0XHRhc3Npc3RhbnQgPSBhd2FpdCBvcGVuYWkubW9kaWZ5QXNzaXN0YW50KHtcblx0XHRcdGFzc2lzdGFudF9pZDogYXNzaXN0YW50LmRhdGEuaWQsXG5cdFx0XHRkZXNjcmlwdGlvbjogYXNzaXN0YW50RGF0YS5kZXNjcmlwdGlvbixcblx0XHRcdGZpbGVfaWRzOiBhc3Npc3RhbnREYXRhLmZpbGVfaWRzLFxuXHRcdFx0aW5zdHJ1Y3Rpb25zOiBhc3Npc3RhbnREYXRhLmluc3RydWN0aW9ucyxcblx0XHRcdG1ldGFkYXRhOiBhc3Npc3RhbnREYXRhLm1ldGFkYXRhLFxuXHRcdFx0bW9kZWw6IGFzc2lzdGFudERhdGEubW9kZWwsXG5cdFx0XHRuYW1lOiBhc3Npc3RhbnREYXRhLm5hbWUsXG5cdFx0XHRyZXRyaWVzOiAwLFxuXHRcdFx0dG9vbHM6IGFzc2lzdGFudERhdGEudG9vbHNcblx0XHR9KVxuXHR9XG5cblx0Ly8gR2V0IHRoZSBsaXN0IG9mIGNhY2hlZCBmaWxlIElEcyBhbmQgbWFrZSBzdXJlIHRoZXkgZXhpc3Rcblx0Y29uc3QgY2FjaGVkRmlsZXMgPVxuXHRcdChhd2FpdCBGbGFzaGNvcmUuZ2V0PFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KCdmaWxlcycsIHtcblx0XHRcdG5hbWVzcGFjZTogX1BSRUZJWFxuXHRcdH0pKSA/PyB7fVxuXHRjb25zdCBjYWNoZWRGaWxlTmFtZXMgPSBPYmplY3Qua2V5cyhjYWNoZWRGaWxlcylcblx0bG9nZ2VyLmRlYnVnKGBGb3VuZCAke2NhY2hlZEZpbGVOYW1lcy5sZW5ndGh9IGNhY2hlZCBmaWxlczpgLCBjYWNoZWRGaWxlTmFtZXMpXG5cblx0Ly8gUmVtb3ZlIGFueSBjYWNoZWQgZmlsZXMgdGhhdCBkb24ndCBleGlzdCBhbnltb3JlXG5cdGlmIChjYWNoZWRGaWxlTmFtZXMubGVuZ3RoID4gMCkge1xuXHRcdGNvbnN0IGZpbGVzID0gYXdhaXQgb3BlbmFpLmxpc3RGaWxlcygpXG5cdFx0Y29uc3QgZmlsZU5hbWVzVG9SZW1vdmUgPSBjYWNoZWRGaWxlTmFtZXMuZmlsdGVyKChmaWxlTmFtZSkgPT4ge1xuXHRcdFx0Y29uc3QgZmlsZUV4aXN0cyA9IGRvY3VtZW50cz8uZmluZCgoZmlsZSkgPT4gZmlsZSA9PT0gZmlsZU5hbWUpXG5cdFx0XHRyZXR1cm4gIWZpbGVFeGlzdHNcblx0XHR9KVxuXHRcdGxvZ2dlci5kZWJ1ZyhgUmVtb3ZpbmcgJHtmaWxlTmFtZXNUb1JlbW92ZS5sZW5ndGh9IGNhY2hlZCBmaWxlczpgLCBmaWxlTmFtZXNUb1JlbW92ZSlcblxuXHRcdC8vIE9ubHkgaWYgYWxzbyBpbiBPcGVuQUkncyBsaXN0IG9mIGZpbGVzXG5cdFx0Y29uc3QgZmlsZUlkc1RvUmVtb3ZlID0gZmlsZU5hbWVzVG9SZW1vdmVcblx0XHRcdC5tYXAoKGZpbGVOYW1lKSA9PiBjYWNoZWRGaWxlc1tmaWxlTmFtZV0pXG5cdFx0XHQuZmlsdGVyKChmaWxlSWQpID0+IHtcblx0XHRcdFx0Y29uc3QgZmlsZUV4aXN0cyA9IGZpbGVzPy5kYXRhPy5maW5kKChmaWxlKSA9PiBmaWxlLmlkID09PSBmaWxlSWQpXG5cdFx0XHRcdHJldHVybiAhIWZpbGVFeGlzdHNcblx0XHRcdH0pXG5cdFx0bG9nZ2VyLmRlYnVnKGBSZW1vdmluZyAke2ZpbGVJZHNUb1JlbW92ZS5sZW5ndGh9IGNhY2hlZCBmaWxlIElEczpgLCBmaWxlSWRzVG9SZW1vdmUpXG5cblx0XHRhd2FpdCBQcm9taXNlLmFsbChcblx0XHRcdGZpbGVJZHNUb1JlbW92ZS5tYXAoYXN5bmMgKGNhY2hlZEZpbGVJZCkgPT4ge1xuXHRcdFx0XHRhd2FpdCBvcGVuYWkuZGVsZXRlRmlsZSh7XG5cdFx0XHRcdFx0ZmlsZV9pZDogY2FjaGVkRmlsZUlkXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGNvbnN0IGZpbGVOYW1lID0gT2JqZWN0LmtleXMoY2FjaGVkRmlsZXMpLmZpbmQoKGZpbGVOYW1lKSA9PiBjYWNoZWRGaWxlc1tmaWxlTmFtZV0gPT09IGNhY2hlZEZpbGVJZClcblx0XHRcdFx0aWYgKGZpbGVOYW1lKSB7XG5cdFx0XHRcdFx0YXdhaXQgRmxhc2hjb3JlLmRlbGV0ZShmaWxlTmFtZSwge1xuXHRcdFx0XHRcdFx0bmFtZXNwYWNlOiBfUFJFRklYICsgJy9maWxlcydcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdGF3YWl0IEZsYXNoY29yZS5zZXQoXG5cdFx0XHRcdFx0XHQnZmlsZXMnLFxuXHRcdFx0XHRcdFx0KGZpbGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSA9PiB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBmaWxlc1tmaWxlTmFtZV1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZpbGVzXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRuYW1lc3BhY2U6IF9QUkVGSVhcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0KVxuXHRcdGxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IHJlbW92ZWQgJHtmaWxlTmFtZXNUb1JlbW92ZS5sZW5ndGh9IGNhY2hlZCBmaWxlcy5gKVxuXHR9XG5cblx0cmV0dXJuIGFzc2lzdGFudFxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBvcHRpbWl6ZWQgYXJyYXkgb2YgR1BUIGZ1bmN0aW9ucyBiYXNlZCBvbiB0aGUgY29tbWFuZHMgdGhpcyBSb2JvIGhhcyBhdmFpbGFibGUuXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZ1bmN0aW9ucyBhbmQgdGhlaXIgaGFuZGxlcnMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRGdW5jdGlvbnMoKSB7XG5cdGNvbnN0IGZ1bmN0aW9uczogQ2hhdEZ1bmN0aW9uW10gPSBbXVxuXHRjb25zdCBmdW5jdGlvbkhhbmRsZXJzOiBSZWNvcmQ8c3RyaW5nLCBDb21tYW5kPiA9IHt9XG5cblx0Ly8gTm9ybWFsaXplIGtleSB0byBhbGxvdyBmb3JtYXRzIGxpa2UgXCIvYWkgYXNrXCIsIFwiYWkvYXNrXCIsIGFuZCBcImFpIGFza1wiXG5cdGxldCB3aGl0ZWxpc3RlZENvbW1hbmRzID0gQXJyYXkuaXNBcnJheShwbHVnaW5PcHRpb25zLmNvbW1hbmRzKSA/IHBsdWdpbk9wdGlvbnMuY29tbWFuZHMgOiBbXVxuXHR3aGl0ZWxpc3RlZENvbW1hbmRzID0gd2hpdGVsaXN0ZWRDb21tYW5kcy5tYXAoKGNvbW1hbmQpID0+IHtcblx0XHRsZXQga2V5ID0gY29tbWFuZFxuXHRcdGlmIChrZXkuYXQoMCkgPT09ICcvJykge1xuXHRcdFx0a2V5ID0ga2V5LnNsaWNlKDEpXG5cdFx0fVxuXHRcdGtleSA9IGtleS5yZXBsYWNlQWxsKCcvJywgJyAnKVxuXG5cdFx0cmV0dXJuIGtleVxuXHR9KVxuXG5cdHBvcnRhbD8uY29tbWFuZHNcblx0XHQuZmlsdGVyKChjb21tYW5kKSA9PiB7XG5cdFx0XHQvLyBPbmx5IGFsbG93IGNvbW1hbmRzIGVuYWJsZWQgaW4gdGhlIHBsdWdpbiBvcHRpb25zXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5PcHRpb25zLmNvbW1hbmRzKSkge1xuXHRcdFx0XHRyZXR1cm4gd2hpdGVsaXN0ZWRDb21tYW5kcy5pbmNsdWRlcyhjb21tYW5kLmtleS5yZXBsYWNlQWxsKCcvJywgJyAnKSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAhIXBsdWdpbk9wdGlvbnMuY29tbWFuZHNcblx0XHRcdH1cblx0XHR9KVxuXHRcdC5mb3JFYWNoKChjb21tYW5kKSA9PiB7XG5cdFx0XHRjb25zdCBjb21tYW5kUGFyYW1ldGVyczogQ2hhdEZ1bmN0aW9uUGFyYW1ldGVycyA9IHtcblx0XHRcdFx0dHlwZTogJ29iamVjdCcsXG5cdFx0XHRcdHJlcXVpcmVkOiBbXSxcblx0XHRcdFx0cHJvcGVydGllczoge31cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBEaXNjb3JkIGNvbW1hbmQgb3B0aW9ucyB0byBHUFQgZnVuY3Rpb24gcGFyYW1ldGVyc1xuXHRcdFx0Y29tbWFuZFBhcmFtZXRlcnMucHJvcGVydGllcyA9XG5cdFx0XHRcdGNvbW1hbmQuaGFuZGxlci5jb25maWc/Lm9wdGlvbnM/LnJlZHVjZSgocHJvcGVydGllcywgb3B0aW9uKSA9PiB7XG5cdFx0XHRcdFx0cHJvcGVydGllc1tvcHRpb24ubmFtZV0gPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnc3RyaW5nJyxcblx0XHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBvcHRpb24uZGVzY3JpcHRpb24gPz8gJydcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG9wdGlvbi5yZXF1aXJlZCkge1xuXHRcdFx0XHRcdFx0Y29tbWFuZFBhcmFtZXRlcnMucmVxdWlyZWQ/LnB1c2gob3B0aW9uLm5hbWUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwcm9wZXJ0aWVzXG5cdFx0XHRcdH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIENoYXRGdW5jdGlvblByb3BlcnR5PikgPz8ge31cblxuXHRcdFx0Ly8gQWRkIHRoZSBHUFQgZnVuY3Rpb24gdG8gdGhlIGxpc3Rcblx0XHRcdGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGNvbW1hbmQua2V5LnJlcGxhY2VBbGwoJy8nLCAnXycpXG5cdFx0XHRmdW5jdGlvbnMucHVzaCh7XG5cdFx0XHRcdG5hbWU6IGZ1bmN0aW9uTmFtZSxcblx0XHRcdFx0ZGVzY3JpcHRpb246IGNvbW1hbmQuZGVzY3JpcHRpb24gPz8gJycsXG5cdFx0XHRcdHBhcmFtZXRlcnM6IGNvbW1hbmRQYXJhbWV0ZXJzXG5cdFx0XHR9KVxuXHRcdFx0ZnVuY3Rpb25IYW5kbGVyc1tmdW5jdGlvbk5hbWVdID0gY29tbWFuZC5oYW5kbGVyXG5cdFx0fSlcblx0bG9nZ2VyLmRlYnVnKGBMb2FkZWQgJHtmdW5jdGlvbnMubGVuZ3RofSBHUFQgZnVuY3Rpb25zOmAsIGZ1bmN0aW9ucylcblxuXHRyZXR1cm4ge1xuXHRcdGZ1bmN0aW9ucyxcblx0XHRmdW5jdGlvbkhhbmRsZXJzXG5cdH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGZ1bmN0aW9uIGNhbGwgdG8gYSBKU09OIHN0cmluZyBsaWtlIHRoZSBvbGRlciBBUEkuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb0pTT04oaW5wdXQ6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuXHQvLyBJZiB0aGUgaW5wdXQgaXMgYWxyZWFkeSBKU09OLCByZXR1cm4gaXRcblx0dHJ5IHtcblx0XHRjb25zdCBqc29uID0gSlNPTi5wYXJzZShpbnB1dClcblx0XHRsb2dnZXIuZGVidWcoYEZ1bmN0aW9uIGNhbGwgaXMgYWxyZWFkeSBKU09OOmAsIGpzb24pXG5cdFx0cmV0dXJuIGpzb25cblx0fSBjYXRjaCB7XG5cdFx0Ly8gRG8gbm90aGluZywgdGhpcyBpcyBmaW5lXG5cdH1cblxuXHQvLyBFeHRyYWN0IHRoZSBmdW5jdGlvbiBuYW1lIGFuZCBwYXJhbWV0ZXJzXG5cdGNvbnN0IG1hdGNoID0gaW5wdXQubWF0Y2goL14oXFx3KylcXCgoLiopXFwpJC8pXG5cdGlmICghbWF0Y2gpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgZm9ybWF0Jylcblx0fVxuXG5cdC8vIFNwbGl0IHBhcmFtZXRlcnMgaW50byBrZXktdmFsdWUgcGFpcnNcblx0Y29uc3QgcGFyYW1zID0gbWF0Y2hbMl0uc3BsaXQoJywnKS5tYXAoKHBhcmFtKSA9PiBwYXJhbS50cmltKCkpXG5cblx0Ly8gQ29uc3RydWN0IGFuIG9iamVjdCBmcm9tIHRoZSBrZXktdmFsdWUgcGFpcnNcblx0Y29uc3QgcmVzdWx0ID0gcGFyYW1zLnJlZHVjZSgob2JqLCBwYXJhbSkgPT4ge1xuXHRcdGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhcmFtLnNwbGl0KCc9JykubWFwKChwKSA9PiBwLnRyaW0oKSlcblxuXHRcdC8vIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzaW5nbGUgcXVvdGVzIGFuZCBAIHN5bWJvbCBmcm9tIHZhbHVlXG5cdFx0Y29uc3QgZm9ybWF0dGVkVmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eJ0A/fCckL2csICcnKVxuXG5cdFx0Ly8gQ2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyIG9mIHRoZSB2YWx1ZSBpZiBpdCdzIG5vdCBhIG51bWJlclxuXHRcdG9ialtrZXldID0gaXNOYU4oZm9ybWF0dGVkVmFsdWUgYXMgdW5rbm93biBhcyBudW1iZXIpXG5cdFx0XHQ/IGZvcm1hdHRlZFZhbHVlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZm9ybWF0dGVkVmFsdWUuc2xpY2UoMSlcblx0XHRcdDogZm9ybWF0dGVkVmFsdWVcblx0XHRyZXR1cm4gb2JqXG5cdH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4pXG5cdGxvZ2dlci5kZWJ1ZyhgQ29udmVydGVkIGZ1bmN0aW9uIGNhbGwgdG8gSlNPTjpgLCByZXN1bHQpXG5cblx0Ly8gQ29udmVydCB0aGUgb2JqZWN0IHRvIGEgSlNPTiBzdHJpbmdcblx0cmV0dXJuIHJlc3VsdFxufVxuIl0sIm5hbWVzIjpbIl9QUkVGSVgiLCJwYWNrYWdlSnNvbiIsImxvZ2dlciIsIkJhc2VFbmdpbmUiLCJvcGVuYWkiLCJvcHRpb25zIiwicGx1Z2luT3B0aW9ucyIsImZzIiwiY29tcGFyZSIsImhhc1Byb3BlcnRpZXMiLCJwYXRoIiwicmVhZEZpbGUiLCJGbGFzaGNvcmUiLCJjb2xvciIsImdldFN0YXRlIiwicG9ydGFsIiwic2V0U3RhdGUiLCJERUZBVUxUX01PREVMIiwiT3BlbkFpRW5naW5lIiwiaW5pdCIsImZ1bmN0aW9ucyIsImZ1bmN0aW9uSGFuZGxlcnMiLCJsb2FkRnVuY3Rpb25zIiwiX2dwdEZ1bmN0aW9ucyIsIl9ncHRGdW5jdGlvbkhhbmRsZXJzIiwiX2Fzc2lzdGFudCIsImxvYWRBc3Npc3RhbnQiLCJjaGF0IiwibWVzc2FnZXMiLCJtb2RlbCIsInRlbXBlcmF0dXJlIiwidGhyZWFkSWQiLCJ1c2VySWQiLCJwb2xsRGVsYXkiLCJtb3N0UmVjZW50TWVzc2FnZSIsImxlbmd0aCIsInRocmVhZE1lc3NhZ2UiLCJyb2xlIiwiY29udGVudCIsIm1ldGFkYXRhIiwidW5kZWZpbmVkIiwidGhyZWFkIiwidGhyZWFkQ3JlYXRlZCIsImFjdGl2ZVJ1biIsIm5hbWVzcGFjZSIsImlkIiwiZGVidWciLCJjcmVhdGVNZXNzYWdlIiwidGhyZWFkX2lkIiwiYm9sZCIsImUiLCJydW5zIiwibGlzdFJ1bnMiLCJhY3RpdmVSdW5zIiwiZGF0YSIsImZpbHRlciIsInJ1biIsImluY2x1ZGVzIiwic3RhdHVzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImNhbmNlbFJ1biIsInJ1bl9pZCIsImNyZWF0ZVJ1biIsImFzc2lzdGFudF9pZCIsInJ1blJlc29sdmUiLCJ2YWx1ZSIsInJ1blByb21pc2UiLCJyZXNvbHZlIiwicmVzcG9uc2UiLCJzZXRUaW1lb3V0IiwiZ2V0UnVuIiwidGhyZWFkTWVzc2FnZXMiLCJnZXRUaHJlYWRNZXNzYWdlcyIsImxpbWl0IiwiZmluaXNoX3JlYXNvbiIsIm1lc3NhZ2UiLCJ0ZXh0IiwiZXJyb3IiLCJFcnJvciIsImZ1bmN0aW9uQ2FsbCIsInJlcXVpcmVkX2FjdGlvbiIsInN1Ym1pdF90b29sX291dHB1dHMiLCJ0b29sX2NhbGxzIiwiZnVuY3Rpb25fY2FsbCIsIm5hbWUiLCJmdW5jdGlvbiIsImFyZ3VtZW50cyIsImNvbnZlcnRUb0pTT04iLCJtYXhfdG9rZW5zIiwibWF4VG9rZW5zIiwicmVwbHkiLCJjaG9pY2VzIiwicmVwbHlGdW5jdGlvbiIsIkpTT04iLCJwYXJzZSIsImdlbmVyYXRlSW1hZ2UiLCJwcm9tcHQiLCJjcmVhdGVJbWFnZSIsImltYWdlcyIsImdldEZ1bmN0aW9uSGFuZGxlcnMiLCJnZXRJbmZvIiwidmVyc2lvbiIsImluc2lnaHQiLCJyb2JvUGFja2FnZUpzb25GaWxlIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJyb2JvUGFja2FnZUpzb24iLCJhc3Npc3RhbnREYXRhIiwiZGVzY3JpcHRpb24iLCJmaWxlX2lkcyIsImluc3RydWN0aW9ucyIsInN5c3RlbU1lc3NhZ2UiLCJwbHVnaW5WZXJzaW9uIiwicm9ib1ZlcnNpb24iLCJkZXBlbmRlbmNpZXMiLCJiYXNlbmFtZSIsInRvb2xzIiwiYXNzaXN0YW50IiwiYXNzaXN0YW50SWQiLCJnZXQiLCJnZXRBc3Npc3RhbnQiLCJhc3Npc3RhbnRzIiwibGlzdEFzc2lzdGFudHMiLCJmaW5kIiwiY3JlYXRlQXNzaXN0YW50IiwiaW5mbyIsInNldCIsImRvY3VtZW50c0RpciIsImRvY3VtZW50cyIsImRvY3VtZW50U3RhdHMiLCJzdGF0IiwiaXNEaXJlY3RvcnkiLCJkaXJzIiwicmVhZGRpciIsInB1c2giLCJ0eXBlIiwiY29kZSIsImRvY3VtZW50UmVzdWx0cyIsImRvY3VtZW50IiwiZmlsZVBhdGgiLCJmaWxlU3RhdHMiLCJ3YXJuIiwiY2FjaGVkRmlsZSIsImJ5dGVzIiwic2l6ZSIsImZpbGVCbG9iIiwiQmxvYiIsImZpbGUiLCJ1cGxvYWRGaWxlIiwicHVycG9zZSIsImZpbGVOYW1lIiwiZmlsZXMiLCJ1cGxvYWRlZERvY3VtZW50cyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiZnVuIiwiZGlmZmVyZW5jZXMiLCJtb2RpZnlBc3Npc3RhbnQiLCJyZXRyaWVzIiwiY2FjaGVkRmlsZXMiLCJjYWNoZWRGaWxlTmFtZXMiLCJsaXN0RmlsZXMiLCJmaWxlTmFtZXNUb1JlbW92ZSIsImZpbGVFeGlzdHMiLCJmaWxlSWRzVG9SZW1vdmUiLCJmaWxlSWQiLCJjYWNoZWRGaWxlSWQiLCJkZWxldGVGaWxlIiwiZmlsZV9pZCIsImRlbGV0ZSIsIndoaXRlbGlzdGVkQ29tbWFuZHMiLCJBcnJheSIsImlzQXJyYXkiLCJjb21tYW5kcyIsImNvbW1hbmQiLCJrZXkiLCJhdCIsInNsaWNlIiwicmVwbGFjZUFsbCIsImNvbW1hbmRQYXJhbWV0ZXJzIiwicmVxdWlyZWQiLCJwcm9wZXJ0aWVzIiwiaGFuZGxlciIsImNvbmZpZyIsInJlZHVjZSIsIm9wdGlvbiIsImZ1bmN0aW9uTmFtZSIsInBhcmFtZXRlcnMiLCJpbnB1dCIsImpzb24iLCJtYXRjaCIsInBhcmFtcyIsInNwbGl0IiwicGFyYW0iLCJ0cmltIiwicmVzdWx0Iiwib2JqIiwicCIsImZvcm1hdHRlZFZhbHVlIiwicmVwbGFjZSIsImlzTmFOIiwiY2hhckF0IiwidG9VcHBlckNhc2UiXSwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLE9BQU8sRUFBRUMsV0FBVyxRQUFRLDRDQUFxQjtBQUMxRCxTQUFTQyxNQUFNLFFBQVEseUNBQWtCO0FBQ3pDLFNBQVNDLFVBQVUsUUFBUSwwQ0FBbUI7QUFDOUMsU0FBOEJDLE1BQU0sUUFBUSxnREFBeUI7QUFDckUsU0FBU0MsV0FBV0MsYUFBYSxRQUFRLDJDQUFvQjtBQUM3RCxPQUFPQyxRQUFRLG1CQUFrQjtBQUNqQyxTQUFTQyxPQUFPLEVBQUVDLGFBQWEsUUFBUSwrQ0FBd0I7QUFDL0QsT0FBT0MsVUFBVSxZQUFXO0FBQzVCLFNBQVNDLFFBQVEsUUFBUSxtQkFBa0I7QUFFM0MsU0FBU0MsU0FBUyxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxRQUFRLFFBQVEsVUFBUztBQWV0RSxNQUFNQyxnQkFBZ0I7QUFFdEI7OztDQUdDLEdBQ0QsT0FBTyxNQUFNQyxxQkFBcUJmO0lBS2pDOztFQUVDLEdBQ0QsTUFBYWdCLE9BQU87UUFDbkIsTUFBTSxFQUFFQyxVQUFTLEVBQUVDLGlCQUFnQixFQUFFLEdBQUcsTUFBTUM7UUFDOUMsSUFBSSxDQUFDQyxhQUFhLEdBQUdIO1FBQ3JCLElBQUksQ0FBQ0ksb0JBQW9CLEdBQUdIO1FBQzVCLElBQUksQ0FBQ0ksVUFBVSxHQUFHLE1BQU1DLGNBQWNOO0lBQ3ZDO0lBRUEsTUFBYU8sS0FBS0MsUUFBdUIsRUFBRXZC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