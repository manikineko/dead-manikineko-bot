import { AI, isReplyingToUser } from "../../../../.robo/build/core/ai.js";
import { chunkMessage, replaceUsernamesWithIds } from "../../../../.robo/build/utils/discord-utils.js";
import { addUserFollowUp } from "../../../../.robo/build/events/typingStart/debounce.js";
import { logger } from "../../../../.robo/build/core/logger.js";
import { options as pluginOptions } from "../../../../.robo/build/events/_start.js";
import { client } from "robo.js";
export default (async (message)=>{
    // Make sure the bot isn't responding to itself
    if (message.author.id === client.user?.id) {
        return;
    }
    // Restrict to specific channels if specified
    const isRestricted = pluginOptions.restrict?.channelIds?.length;
    if (isRestricted && !pluginOptions.restrict?.channelIds?.includes(message.channelId)) {
        logger.debug(`Message received in channel ${message.channelId} but restricted to specific channels`);
        return;
    }
    // Don't respond unless mentioned unless in whitelisted channel or DM
    const isOpenConvo = pluginOptions.whitelist?.channelIds?.includes(message.channel.id) || message.channel.isDMBased();
    if (!message.mentions.users.has(client.user?.id ?? '') && !isOpenConvo) {
        if (isReplyingToUser(message.author.id)) {
            addUserFollowUp(message.author.id, message, message.content);
            logger.debug(`Added follow up message for ${message.author.username} but not mentioned`);
        } else {
            logger.debug(`Message received but not mentioned`);
        }
        return;
    }
    // Target referenced message if replying to someone else
    let targetMessage = message;
    if (message.reference?.messageId) {
        const referencedMessage = await message.channel.messages.fetch(message.reference.messageId);
        if (referencedMessage.author.id !== client.user?.id) {
            targetMessage = referencedMessage;
            // Make sure to include context if there is any
            if (message.content.replaceAll(`<@${client.user?.id}>`, '').trim()) {
                targetMessage.content = message.content + '\n' + targetMessage.content;
            }
        }
    }
    // Replace mentions with usernames
    let processedContent = targetMessage.content.replaceAll(`<@${client.user?.username}>`, '@' + client.user?.username);
    for (const user of targetMessage.mentions.users.values()){
        processedContent = processedContent.replaceAll(`<@${user.id}>`, '@' + user.username);
    }
    // Replace role mentions with role names
    for (const role of targetMessage.mentions.roles.values()){
        processedContent = processedContent.replaceAll(`<@&${role.id}>`, '@' + role.name);
    }
    // Replace channel mentions with channel names
    for (const channel of targetMessage.mentions.channels.values()){
        if (!channel.isDMBased()) {
            processedContent = processedContent.replaceAll(`<#${channel.id}>`, '#' + channel.name);
        }
    }
    // If currently already replying to this user, add as follow up context
    if (isReplyingToUser(targetMessage.author.id)) {
        addUserFollowUp(targetMessage.author.id, targetMessage, processedContent);
        logger.debug(`Added follow up message for @${targetMessage.author.username} because already replying`);
        return;
    }
    // Include reply chain messages for context
    const messages = [
        {
            ...targetMessage,
            content: processedContent
        }
    ];
    try {
        const replyChain = await getReplyChain(targetMessage, {
            context: isOpenConvo ? 'channel' : 'reference'
        });
        if (replyChain) {
            messages.unshift(...replyChain);
        }
    } catch (error) {
        logger.warn(`Error getting reply chain`, error);
    }
    // Create map of usernames to user IDs
    const userMap = {};
    const userIterator = targetMessage.guild ? targetMessage.guild.members.cache.values() : [];
    for (const user of userIterator){
        userMap[user.user.username] = user.user.id;
    }
    // Structure messages for GPT
    const gptMessages = messages.map((message)=>({
            role: message.author.id === client.user?.id ? 'assistant' : 'user',
            content: getMessageContent(message)
        }));
    await AI.chat(gptMessages, {
        channel: message.channel,
        member: message.member ?? message.guild?.members.cache.get(message.author.id),
        onReply: async (reply)=>{
            let { components , embeds , files  } = reply;
            const chunks = chunkMessage(reply.text ?? '');
            let lastMessage = targetMessage;
            // If there's no chunks to split, just send special data
            if (!chunks.length) {
                await lastMessage.reply({
                    components,
                    embeds,
                    files
                });
                return;
            }
            for (const chunk of chunks){
                const content = replaceUsernamesWithIds(chunk, userMap);
                lastMessage = await lastMessage.reply({
                    content,
                    components,
                    embeds,
                    files
                });
                components = undefined;
                embeds = undefined;
                files = undefined;
            }
        }
    });
});
// TODO: Handle prefix for answer-other differently! (dedicated processContent function?)
function getMessageContent(message) {
    // Prefix who sent the message (who to refer to)
    const content = message.author.username + ': ' + message.content;
    // Include attachments if they exist and the model supports it
    if (message.attachments?.size && pluginOptions.model?.includes('vision')) {
        logger.debug(`Including ${message.attachments.size} attachments`);
        return [
            {
                type: 'text',
                text: content
            },
            ...message.attachments.map((attachment)=>({
                    type: 'image_url',
                    image_url: attachment.url
                }))
        ];
    }
    return content;
}
async function getReplyChain(message, options) {
    const { context ='reference' , depth =3  } = options ?? {};
    if (depth <= 0) {
        throw new Error(`Message reply chain depth must be greater than 0`);
    }
    let chain = [];
    let currentMessage = message;
    if (context === 'channel') {
        // Load messages before the current message
        const messages = await message.channel.messages.fetch({
            before: message.id,
            limit: depth
        });
        chain = [
            ...messages.values()
        ];
    } else if (context === 'reference') {
        while(chain.length < depth){
            const referenceId = currentMessage.reference?.messageId;
            if (referenceId) {
                currentMessage = await message.channel.messages.fetch(referenceId);
                chain.push(currentMessage);
            } else {
                break;
            }
        }
    }
    return chain.reverse();
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL3JvYm8uanMvcm9iby5qcy9wYWNrYWdlcy9wbHVnaW4tYWkvc3JjL2V2ZW50cy9tZXNzYWdlQ3JlYXRlL2NoYXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQUksIGlzUmVwbHlpbmdUb1VzZXIgfSBmcm9tICdAL2NvcmUvYWkuanMnXG5pbXBvcnQgeyBjaHVua01lc3NhZ2UsIHJlcGxhY2VVc2VybmFtZXNXaXRoSWRzIH0gZnJvbSAnQC91dGlscy9kaXNjb3JkLXV0aWxzLmpzJ1xuaW1wb3J0IHsgYWRkVXNlckZvbGxvd1VwIH0gZnJvbSAnQC9ldmVudHMvdHlwaW5nU3RhcnQvZGVib3VuY2UuanMnXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdAL2NvcmUvbG9nZ2VyLmpzJ1xuaW1wb3J0IHsgb3B0aW9ucyBhcyBwbHVnaW5PcHRpb25zIH0gZnJvbSAnQC9ldmVudHMvX3N0YXJ0LmpzJ1xuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gJ2Rpc2NvcmQuanMnXG5pbXBvcnQgeyBjbGllbnQgfSBmcm9tICdyb2JvLmpzJ1xuaW1wb3J0IHR5cGUgeyBDaGF0TWVzc2FnZSwgQ2hhdE1lc3NhZ2VDb250ZW50IH0gZnJvbSAnQC9lbmdpbmVzL2Jhc2UuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIChtZXNzYWdlOiBNZXNzYWdlKSA9PiB7XG5cdC8vIE1ha2Ugc3VyZSB0aGUgYm90IGlzbid0IHJlc3BvbmRpbmcgdG8gaXRzZWxmXG5cdGlmIChtZXNzYWdlLmF1dGhvci5pZCA9PT0gY2xpZW50LnVzZXI/LmlkKSB7XG5cdFx0cmV0dXJuXG5cdH1cblxuXHQvLyBSZXN0cmljdCB0byBzcGVjaWZpYyBjaGFubmVscyBpZiBzcGVjaWZpZWRcblx0Y29uc3QgaXNSZXN0cmljdGVkID0gcGx1Z2luT3B0aW9ucy5yZXN0cmljdD8uY2hhbm5lbElkcz8ubGVuZ3RoXG5cdGlmIChpc1Jlc3RyaWN0ZWQgJiYgIXBsdWdpbk9wdGlvbnMucmVzdHJpY3Q/LmNoYW5uZWxJZHM/LmluY2x1ZGVzKG1lc3NhZ2UuY2hhbm5lbElkKSkge1xuXHRcdGxvZ2dlci5kZWJ1ZyhgTWVzc2FnZSByZWNlaXZlZCBpbiBjaGFubmVsICR7bWVzc2FnZS5jaGFubmVsSWR9IGJ1dCByZXN0cmljdGVkIHRvIHNwZWNpZmljIGNoYW5uZWxzYClcblx0XHRyZXR1cm5cblx0fVxuXG5cdC8vIERvbid0IHJlc3BvbmQgdW5sZXNzIG1lbnRpb25lZCB1bmxlc3MgaW4gd2hpdGVsaXN0ZWQgY2hhbm5lbCBvciBETVxuXHRjb25zdCBpc09wZW5Db252byA9IHBsdWdpbk9wdGlvbnMud2hpdGVsaXN0Py5jaGFubmVsSWRzPy5pbmNsdWRlcyhtZXNzYWdlLmNoYW5uZWwuaWQpIHx8IG1lc3NhZ2UuY2hhbm5lbC5pc0RNQmFzZWQoKVxuXHRpZiAoIW1lc3NhZ2UubWVudGlvbnMudXNlcnMuaGFzKGNsaWVudC51c2VyPy5pZCA/PyAnJykgJiYgIWlzT3BlbkNvbnZvKSB7XG5cdFx0aWYgKGlzUmVwbHlpbmdUb1VzZXIobWVzc2FnZS5hdXRob3IuaWQpKSB7XG5cdFx0XHRhZGRVc2VyRm9sbG93VXAobWVzc2FnZS5hdXRob3IuaWQsIG1lc3NhZ2UsIG1lc3NhZ2UuY29udGVudClcblx0XHRcdGxvZ2dlci5kZWJ1ZyhgQWRkZWQgZm9sbG93IHVwIG1lc3NhZ2UgZm9yICR7bWVzc2FnZS5hdXRob3IudXNlcm5hbWV9IGJ1dCBub3QgbWVudGlvbmVkYClcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKGBNZXNzYWdlIHJlY2VpdmVkIGJ1dCBub3QgbWVudGlvbmVkYClcblx0XHR9XG5cblx0XHRyZXR1cm5cblx0fVxuXG5cdC8vIFRhcmdldCByZWZlcmVuY2VkIG1lc3NhZ2UgaWYgcmVwbHlpbmcgdG8gc29tZW9uZSBlbHNlXG5cdGxldCB0YXJnZXRNZXNzYWdlID0gbWVzc2FnZVxuXHRpZiAobWVzc2FnZS5yZWZlcmVuY2U/Lm1lc3NhZ2VJZCkge1xuXHRcdGNvbnN0IHJlZmVyZW5jZWRNZXNzYWdlID0gYXdhaXQgbWVzc2FnZS5jaGFubmVsLm1lc3NhZ2VzLmZldGNoKG1lc3NhZ2UucmVmZXJlbmNlLm1lc3NhZ2VJZClcblxuXHRcdGlmIChyZWZlcmVuY2VkTWVzc2FnZS5hdXRob3IuaWQgIT09IGNsaWVudC51c2VyPy5pZCkge1xuXHRcdFx0dGFyZ2V0TWVzc2FnZSA9IHJlZmVyZW5jZWRNZXNzYWdlXG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0byBpbmNsdWRlIGNvbnRleHQgaWYgdGhlcmUgaXMgYW55XG5cdFx0XHRpZiAobWVzc2FnZS5jb250ZW50LnJlcGxhY2VBbGwoYDxAJHtjbGllbnQudXNlcj8uaWR9PmAsICcnKS50cmltKCkpIHtcblx0XHRcdFx0dGFyZ2V0TWVzc2FnZS5jb250ZW50ID0gbWVzc2FnZS5jb250ZW50ICsgJ1xcbicgKyB0YXJnZXRNZXNzYWdlLmNvbnRlbnRcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXBsYWNlIG1lbnRpb25zIHdpdGggdXNlcm5hbWVzXG5cdGxldCBwcm9jZXNzZWRDb250ZW50ID0gdGFyZ2V0TWVzc2FnZS5jb250ZW50LnJlcGxhY2VBbGwoYDxAJHtjbGllbnQudXNlcj8udXNlcm5hbWV9PmAsICdAJyArIGNsaWVudC51c2VyPy51c2VybmFtZSlcblx0Zm9yIChjb25zdCB1c2VyIG9mIHRhcmdldE1lc3NhZ2UubWVudGlvbnMudXNlcnMudmFsdWVzKCkpIHtcblx0XHRwcm9jZXNzZWRDb250ZW50ID0gcHJvY2Vzc2VkQ29udGVudC5yZXBsYWNlQWxsKGA8QCR7dXNlci5pZH0+YCwgJ0AnICsgdXNlci51c2VybmFtZSlcblx0fVxuXG5cdC8vIFJlcGxhY2Ugcm9sZSBtZW50aW9ucyB3aXRoIHJvbGUgbmFtZXNcblx0Zm9yIChjb25zdCByb2xlIG9mIHRhcmdldE1lc3NhZ2UubWVudGlvbnMucm9sZXMudmFsdWVzKCkpIHtcblx0XHRwcm9jZXNzZWRDb250ZW50ID0gcHJvY2Vzc2VkQ29udGVudC5yZXBsYWNlQWxsKGA8QCYke3JvbGUuaWR9PmAsICdAJyArIHJvbGUubmFtZSlcblx0fVxuXG5cdC8vIFJlcGxhY2UgY2hhbm5lbCBtZW50aW9ucyB3aXRoIGNoYW5uZWwgbmFtZXNcblx0Zm9yIChjb25zdCBjaGFubmVsIG9mIHRhcmdldE1lc3NhZ2UubWVudGlvbnMuY2hhbm5lbHMudmFsdWVzKCkpIHtcblx0XHRpZiAoIWNoYW5uZWwuaXNETUJhc2VkKCkpIHtcblx0XHRcdHByb2Nlc3NlZENvbnRlbnQgPSBwcm9jZXNzZWRDb250ZW50LnJlcGxhY2VBbGwoYDwjJHtjaGFubmVsLmlkfT5gLCAnIycgKyBjaGFubmVsLm5hbWUpXG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgY3VycmVudGx5IGFscmVhZHkgcmVwbHlpbmcgdG8gdGhpcyB1c2VyLCBhZGQgYXMgZm9sbG93IHVwIGNvbnRleHRcblx0aWYgKGlzUmVwbHlpbmdUb1VzZXIodGFyZ2V0TWVzc2FnZS5hdXRob3IuaWQpKSB7XG5cdFx0YWRkVXNlckZvbGxvd1VwKHRhcmdldE1lc3NhZ2UuYXV0aG9yLmlkLCB0YXJnZXRNZXNzYWdlLCBwcm9jZXNzZWRDb250ZW50KVxuXHRcdGxvZ2dlci5kZWJ1ZyhgQWRkZWQgZm9sbG93IHVwIG1lc3NhZ2UgZm9yIEAke3RhcmdldE1lc3NhZ2UuYXV0aG9yLnVzZXJuYW1lfSBiZWNhdXNlIGFscmVhZHkgcmVwbHlpbmdgKVxuXHRcdHJldHVyblxuXHR9XG5cblx0Ly8gSW5jbHVkZSByZXBseSBjaGFpbiBtZXNzYWdlcyBmb3IgY29udGV4dFxuXHRjb25zdCBtZXNzYWdlcyA9IFt7IC4uLnRhcmdldE1lc3NhZ2UsIGNvbnRlbnQ6IHByb2Nlc3NlZENvbnRlbnQgfSBhcyBNZXNzYWdlXVxuXHR0cnkge1xuXHRcdGNvbnN0IHJlcGx5Q2hhaW4gPSBhd2FpdCBnZXRSZXBseUNoYWluKHRhcmdldE1lc3NhZ2UsIHtcblx0XHRcdGNvbnRleHQ6IGlzT3BlbkNvbnZvID8gJ2NoYW5uZWwnIDogJ3JlZmVyZW5jZSdcblx0XHR9KVxuXHRcdGlmIChyZXBseUNoYWluKSB7XG5cdFx0XHRtZXNzYWdlcy51bnNoaWZ0KC4uLnJlcGx5Q2hhaW4pXG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZ2dlci53YXJuKGBFcnJvciBnZXR0aW5nIHJlcGx5IGNoYWluYCwgZXJyb3IpXG5cdH1cblxuXHQvLyBDcmVhdGUgbWFwIG9mIHVzZXJuYW1lcyB0byB1c2VyIElEc1xuXHRjb25zdCB1c2VyTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cblx0Y29uc3QgdXNlckl0ZXJhdG9yID0gdGFyZ2V0TWVzc2FnZS5ndWlsZCA/IHRhcmdldE1lc3NhZ2UuZ3VpbGQubWVtYmVycy5jYWNoZS52YWx1ZXMoKSA6IFtdXG5cdGZvciAoY29uc3QgdXNlciBvZiB1c2VySXRlcmF0b3IpIHtcblx0XHR1c2VyTWFwW3VzZXIudXNlci51c2VybmFtZV0gPSB1c2VyLnVzZXIuaWRcblx0fVxuXG5cdC8vIFN0cnVjdHVyZSBtZXNzYWdlcyBmb3IgR1BUXG5cdGNvbnN0IGdwdE1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdID0gbWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiAoe1xuXHRcdHJvbGU6IG1lc3NhZ2UuYXV0aG9yLmlkID09PSBjbGllbnQudXNlcj8uaWQgPyAnYXNzaXN0YW50JyA6ICd1c2VyJyxcblx0XHRjb250ZW50OiBnZXRNZXNzYWdlQ29udGVudChtZXNzYWdlKVxuXHR9KSlcblxuXHRhd2FpdCBBSS5jaGF0KGdwdE1lc3NhZ2VzLCB7XG5cdFx0Y2hhbm5lbDogbWVzc2FnZS5jaGFubmVsLFxuXHRcdG1lbWJlcjogbWVzc2FnZS5tZW1iZXIgPz8gbWVzc2FnZS5ndWlsZD8ubWVtYmVycy5jYWNoZS5nZXQobWVzc2FnZS5hdXRob3IuaWQpLFxuXHRcdG9uUmVwbHk6IGFzeW5jIChyZXBseSkgPT4ge1xuXHRcdFx0bGV0IHsgY29tcG9uZW50cywgZW1iZWRzLCBmaWxlcyB9ID0gcmVwbHlcblx0XHRcdGNvbnN0IGNodW5rcyA9IGNodW5rTWVzc2FnZShyZXBseS50ZXh0ID8/ICcnKVxuXHRcdFx0bGV0IGxhc3RNZXNzYWdlID0gdGFyZ2V0TWVzc2FnZVxuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG5vIGNodW5rcyB0byBzcGxpdCwganVzdCBzZW5kIHNwZWNpYWwgZGF0YVxuXHRcdFx0aWYgKCFjaHVua3MubGVuZ3RoKSB7XG5cdFx0XHRcdGF3YWl0IGxhc3RNZXNzYWdlLnJlcGx5KHtcblx0XHRcdFx0XHRjb21wb25lbnRzLFxuXHRcdFx0XHRcdGVtYmVkcyxcblx0XHRcdFx0XHRmaWxlc1xuXHRcdFx0XHR9KVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IHJlcGxhY2VVc2VybmFtZXNXaXRoSWRzKGNodW5rLCB1c2VyTWFwKVxuXHRcdFx0XHRsYXN0TWVzc2FnZSA9IGF3YWl0IGxhc3RNZXNzYWdlLnJlcGx5KHtcblx0XHRcdFx0XHRjb250ZW50LFxuXHRcdFx0XHRcdGNvbXBvbmVudHMsXG5cdFx0XHRcdFx0ZW1iZWRzLFxuXHRcdFx0XHRcdGZpbGVzXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGNvbXBvbmVudHMgPSB1bmRlZmluZWRcblx0XHRcdFx0ZW1iZWRzID0gdW5kZWZpbmVkXG5cdFx0XHRcdGZpbGVzID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHR9KVxufVxuXG4vLyBUT0RPOiBIYW5kbGUgcHJlZml4IGZvciBhbnN3ZXItb3RoZXIgZGlmZmVyZW50bHkhIChkZWRpY2F0ZWQgcHJvY2Vzc0NvbnRlbnQgZnVuY3Rpb24/KVxuZnVuY3Rpb24gZ2V0TWVzc2FnZUNvbnRlbnQobWVzc2FnZTogTWVzc2FnZSk6IENoYXRNZXNzYWdlQ29udGVudCB7XG5cdC8vIFByZWZpeCB3aG8gc2VudCB0aGUgbWVzc2FnZSAod2hvIHRvIHJlZmVyIHRvKVxuXHRjb25zdCBjb250ZW50ID0gbWVzc2FnZS5hdXRob3IudXNlcm5hbWUgKyAnOiAnICsgbWVzc2FnZS5jb250ZW50XG5cblx0Ly8gSW5jbHVkZSBhdHRhY2htZW50cyBpZiB0aGV5IGV4aXN0IGFuZCB0aGUgbW9kZWwgc3VwcG9ydHMgaXRcblx0aWYgKG1lc3NhZ2UuYXR0YWNobWVudHM/LnNpemUgJiYgcGx1Z2luT3B0aW9ucy5tb2RlbD8uaW5jbHVkZXMoJ3Zpc2lvbicpKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKGBJbmNsdWRpbmcgJHttZXNzYWdlLmF0dGFjaG1lbnRzLnNpemV9IGF0dGFjaG1lbnRzYClcblxuXHRcdHJldHVybiBbXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6ICd0ZXh0Jyxcblx0XHRcdFx0dGV4dDogY29udGVudFxuXHRcdFx0fSxcblx0XHRcdC4uLm1lc3NhZ2UuYXR0YWNobWVudHMubWFwKFxuXHRcdFx0XHQoYXR0YWNobWVudCkgPT5cblx0XHRcdFx0XHQoe1xuXHRcdFx0XHRcdFx0dHlwZTogJ2ltYWdlX3VybCcsXG5cdFx0XHRcdFx0XHRpbWFnZV91cmw6IGF0dGFjaG1lbnQudXJsXG5cdFx0XHRcdFx0fSBhcyBjb25zdClcblx0XHRcdClcblx0XHRdXG5cdH1cblxuXHRyZXR1cm4gY29udGVudFxufVxuXG5pbnRlcmZhY2UgUmVwbHlDaGFpbk9wdGlvbnMge1xuXHRjb250ZXh0PzogJ2NoYW5uZWwnIHwgJ3JlZmVyZW5jZSdcblx0ZGVwdGg/OiBudW1iZXJcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlcGx5Q2hhaW4obWVzc2FnZTogTWVzc2FnZSwgb3B0aW9ucz86IFJlcGx5Q2hhaW5PcHRpb25zKTogUHJvbWlzZTxNZXNzYWdlW10+IHtcblx0Y29uc3QgeyBjb250ZXh0ID0gJ3JlZmVyZW5jZScsIGRlcHRoID0gMyB9ID0gb3B0aW9ucyA/PyB7fVxuXG5cdGlmIChkZXB0aCA8PSAwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBNZXNzYWdlIHJlcGx5IGNoYWluIGRlcHRoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBgKVxuXHR9XG5cblx0bGV0IGNoYWluOiBNZXNzYWdlW10gPSBbXVxuXHRsZXQgY3VycmVudE1lc3NhZ2UgPSBtZXNzYWdlXG5cblx0aWYgKGNvbnRleHQgPT09ICdjaGFubmVsJykge1xuXHRcdC8vIExvYWQgbWVzc2FnZXMgYmVmb3JlIHRoZSBjdXJyZW50IG1lc3NhZ2Vcblx0XHRjb25zdCBtZXNzYWdlcyA9IGF3YWl0IG1lc3NhZ2UuY2hhbm5lbC5tZXNzYWdlcy5mZXRjaCh7IGJlZm9yZTogbWVzc2FnZS5pZCwgbGltaXQ6IGRlcHRoIH0pXG5cdFx0Y2hhaW4gPSBbLi4ubWVzc2FnZXMudmFsdWVzKCldXG5cdH0gZWxzZSBpZiAoY29udGV4dCA9PT0gJ3JlZmVyZW5jZScpIHtcblx0XHR3aGlsZSAoY2hhaW4ubGVuZ3RoIDwgZGVwdGgpIHtcblx0XHRcdGNvbnN0IHJlZmVyZW5jZUlkID0gY3VycmVudE1lc3NhZ2UucmVmZXJlbmNlPy5tZXNzYWdlSWRcblx0XHRcdGlmIChyZWZlcmVuY2VJZCkge1xuXHRcdFx0XHRjdXJyZW50TWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2UuY2hhbm5lbC5tZXNzYWdlcy5mZXRjaChyZWZlcmVuY2VJZClcblx0XHRcdFx0Y2hhaW4ucHVzaChjdXJyZW50TWVzc2FnZSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluLnJldmVyc2UoKVxufVxuIl0sIm5hbWVzIjpbIkFJIiwiaXNSZXBseWluZ1RvVXNlciIsImNodW5rTWVzc2FnZSIsInJlcGxhY2VVc2VybmFtZXNXaXRoSWRzIiwiYWRkVXNlckZvbGxvd1VwIiwibG9nZ2VyIiwib3B0aW9ucyIsInBsdWdpbk9wdGlvbnMiLCJjbGllbnQiLCJtZXNzYWdlIiwiYXV0aG9yIiwiaWQiLCJ1c2VyIiwiaXNSZXN0cmljdGVkIiwicmVzdHJpY3QiLCJjaGFubmVsSWRzIiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJjaGFubmVsSWQiLCJkZWJ1ZyIsImlzT3BlbkNvbnZvIiwid2hpdGVsaXN0IiwiY2hhbm5lbCIsImlzRE1CYXNlZCIsIm1lbnRpb25zIiwidXNlcnMiLCJoYXMiLCJjb250ZW50IiwidXNlcm5hbWUiLCJ0YXJnZXRNZXNzYWdlIiwicmVmZXJlbmNlIiwibWVzc2FnZUlkIiwicmVmZXJlbmNlZE1lc3NhZ2UiLCJtZXNzYWdlcyIsImZldGNoIiwicmVwbGFjZUFsbCIsInRyaW0iLCJwcm9jZXNzZWRDb250ZW50IiwidmFsdWVzIiwicm9sZSIsInJvbGVzIiwibmFtZSIsImNoYW5uZWxzIiwicmVwbHlDaGFpbiIsImdldFJlcGx5Q2hhaW4iLCJjb250ZXh0IiwidW5zaGlmdCIsImVycm9yIiwid2FybiIsInVzZXJNYXAiLCJ1c2VySXRlcmF0b3IiLCJndWlsZCIsIm1lbWJlcnMiLCJjYWNoZSIsImdwdE1lc3NhZ2VzIiwibWFwIiwiZ2V0TWVzc2FnZUNvbnRlbnQiLCJjaGF0IiwibWVtYmVyIiwiZ2V0Iiwib25SZXBseSIsInJlcGx5IiwiY29tcG9uZW50cyIsImVtYmVkcyIsImZpbGVzIiwiY2h1bmtzIiwidGV4dCIsImxhc3RNZXNzYWdlIiwiY2h1bmsiLCJ1bmRlZmluZWQiLCJhdHRhY2htZW50cyIsInNpemUiLCJtb2RlbCIsInR5cGUiLCJhdHRhY2htZW50IiwiaW1hZ2VfdXJsIiwidXJsIiwiZGVwdGgiLCJFcnJvciIsImNoYWluIiwiY3VycmVudE1lc3NhZ2UiLCJiZWZvcmUiLCJsaW1pdCIsInJlZmVyZW5jZUlkIiwicHVzaCIsInJldmVyc2UiXSwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLEVBQUUsRUFBRUMsZ0JBQWdCLFFBQVEscUNBQWM7QUFDbkQsU0FBU0MsWUFBWSxFQUFFQyx1QkFBdUIsUUFBUSxpREFBMEI7QUFDaEYsU0FBU0MsZUFBZSxRQUFRLHlEQUFrQztBQUNsRSxTQUFTQyxNQUFNLFFBQVEseUNBQWtCO0FBQ3pDLFNBQVNDLFdBQVdDLGFBQWEsUUFBUSwyQ0FBb0I7QUFFN0QsU0FBU0MsTUFBTSxRQUFRLFVBQVM7QUFHaEMsZUFB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