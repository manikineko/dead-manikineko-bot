import { isReplyingToUser } from "../../../../.robo/build/core/ai.js";
import { logger } from "../../../../.robo/build/core/logger.js";
import { client } from "robo.js";
// 10 seconds emulates Discord's typing indicator timeout
const DEBOUNCE_TIME = 10_000;
// Never wait longer than 1 second in case the message was sent
const DEBOUNCE_MAX = 1_000;
/**
 * When a user currently being replied to starts typing, delay the reply.
 * This allows us to have a more natural conversation flow and better context.
 */ export default ((event)=>{
    const { user  } = event;
    // Don't debounce for self
    if (user.id === client.user?.id) {
        return;
    }
    // Don't do anything unless currently replying to a user
    if (!isReplyingToUser(user.id)) {
        logger.debug(`User @${user.username} started typing but not currently replying`);
        return;
    }
    logger.debug(`User @${user.username} started typing`);
    // Clear any existing debounce
    const state = UserStatus[event.user.id];
    if (state?.debounce) {
        clearTimeout(state.debounce);
    }
    // If not already typing, assume new context
    if (state && !state.activities?.has('typing')) {
        state.context = [];
    }
    // Set a new debounce
    const debounce = setTimeout(()=>{
        clearTimeout(debounce);
        clearUserTyping(event.user.id);
    }, DEBOUNCE_TIME + 100);
    // Update user state
    if (state) {
        state.activities.add('typing');
        state.debounce = debounce;
        state.lastTypedAt = Date.now();
        return;
    } else {
        UserStatus[event.user.id] = {
            activities: new Set().add('typing'),
            context: [],
            debounce: debounce,
            lastTypedAt: Date.now()
        };
    }
});
const UserStatus = {};
export function addUserFollowUp(userId, message, messageContent) {
    const state = UserStatus[userId];
    // Don't add follow-ups if the user isn't typing
    if (!state?.activities?.has('typing')) {
        logger.debug(`User @${userId} isn't typing, can't add follow-up`);
        return;
    }
    // Add the message to the user's context
    state.context.push(message.author.username + ': ' + messageContent);
    clearUserTyping(userId);
}
export function clearUserTyping(userId) {
    const state = UserStatus[userId];
    if (!state) {
        return;
    }
    clearTimeout(state.debounce);
    state.activities.delete('typing');
    logger.debug(`Cleared typing state for @${userId}`);
}
export function isUserTyping(userId) {
    const state = UserStatus[userId];
    // No state means the user isn't typing
    if (!state) {
        return false;
    }
    // No active typing means the user isn't typing
    if (!state.activities.has('typing')) {
        return false;
    }
    // Not having typed in a while means the user isn't typing
    if (Date.now() - state.lastTypedAt > DEBOUNCE_TIME) {
        return false;
    }
    return true;
}
export function waitForTyping(userId) {
    return new Promise((resolve)=>{
        const run = async ()=>{
            // Loop until the user stops typing
            while(isUserTyping(userId)){
                const state = UserStatus[userId];
                // Delay by the remaining debounce time (up to max in case message was sent)
                const remaining = Math.min(DEBOUNCE_TIME - (Date.now() - state.lastTypedAt), DEBOUNCE_MAX);
                logger.debug(`Waiting for user @${userId} to stop typing (${remaining}ms)`);
                await new Promise((resolve)=>setTimeout(resolve, remaining));
            }
            // Resolve with the user's context (while clearing for next time)
            const state = UserStatus[userId];
            const context = state?.context ?? [];
            if (state) {
                state.context = [];
                clearUserTyping(userId);
            }
            logger.debug(`User @${userId} stopped typing. Context:`, context);
            resolve(context);
        };
        run();
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL3JvYm8uanMvcm9iby5qcy9wYWNrYWdlcy9wbHVnaW4tYWkvc3JjL2V2ZW50cy90eXBpbmdTdGFydC9kZWJvdW5jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1JlcGx5aW5nVG9Vc2VyIH0gZnJvbSAnQC9jb3JlL2FpLmpzJ1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnQC9jb3JlL2xvZ2dlci5qcydcbmltcG9ydCB7IGNsaWVudCB9IGZyb20gJ3JvYm8uanMnXG5pbXBvcnQgdHlwZSB7IE1lc3NhZ2UsIFR5cGluZyB9IGZyb20gJ2Rpc2NvcmQuanMnXG5cbi8vIDEwIHNlY29uZHMgZW11bGF0ZXMgRGlzY29yZCdzIHR5cGluZyBpbmRpY2F0b3IgdGltZW91dFxuY29uc3QgREVCT1VOQ0VfVElNRSA9IDEwXzAwMFxuXG4vLyBOZXZlciB3YWl0IGxvbmdlciB0aGFuIDEgc2Vjb25kIGluIGNhc2UgdGhlIG1lc3NhZ2Ugd2FzIHNlbnRcbmNvbnN0IERFQk9VTkNFX01BWCA9IDFfMDAwXG5cbi8qKlxuICogV2hlbiBhIHVzZXIgY3VycmVudGx5IGJlaW5nIHJlcGxpZWQgdG8gc3RhcnRzIHR5cGluZywgZGVsYXkgdGhlIHJlcGx5LlxuICogVGhpcyBhbGxvd3MgdXMgdG8gaGF2ZSBhIG1vcmUgbmF0dXJhbCBjb252ZXJzYXRpb24gZmxvdyBhbmQgYmV0dGVyIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IChldmVudDogVHlwaW5nKSA9PiB7XG5cdGNvbnN0IHsgdXNlciB9ID0gZXZlbnRcblxuXHQvLyBEb24ndCBkZWJvdW5jZSBmb3Igc2VsZlxuXHRpZiAodXNlci5pZCA9PT0gY2xpZW50LnVzZXI/LmlkKSB7XG5cdFx0cmV0dXJuXG5cdH1cblxuXHQvLyBEb24ndCBkbyBhbnl0aGluZyB1bmxlc3MgY3VycmVudGx5IHJlcGx5aW5nIHRvIGEgdXNlclxuXHRpZiAoIWlzUmVwbHlpbmdUb1VzZXIodXNlci5pZCkpIHtcblx0XHRsb2dnZXIuZGVidWcoYFVzZXIgQCR7dXNlci51c2VybmFtZX0gc3RhcnRlZCB0eXBpbmcgYnV0IG5vdCBjdXJyZW50bHkgcmVwbHlpbmdgKVxuXHRcdHJldHVyblxuXHR9XG5cdGxvZ2dlci5kZWJ1ZyhgVXNlciBAJHt1c2VyLnVzZXJuYW1lfSBzdGFydGVkIHR5cGluZ2ApXG5cblx0Ly8gQ2xlYXIgYW55IGV4aXN0aW5nIGRlYm91bmNlXG5cdGNvbnN0IHN0YXRlID0gVXNlclN0YXR1c1tldmVudC51c2VyLmlkXVxuXHRpZiAoc3RhdGU/LmRlYm91bmNlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHN0YXRlLmRlYm91bmNlKVxuXHR9XG5cblx0Ly8gSWYgbm90IGFscmVhZHkgdHlwaW5nLCBhc3N1bWUgbmV3IGNvbnRleHRcblx0aWYgKHN0YXRlICYmICFzdGF0ZS5hY3Rpdml0aWVzPy5oYXMoJ3R5cGluZycpKSB7XG5cdFx0c3RhdGUuY29udGV4dCA9IFtdXG5cdH1cblxuXHQvLyBTZXQgYSBuZXcgZGVib3VuY2Vcblx0Y29uc3QgZGVib3VuY2UgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQoZGVib3VuY2UpXG5cdFx0Y2xlYXJVc2VyVHlwaW5nKGV2ZW50LnVzZXIuaWQpXG5cdH0sIERFQk9VTkNFX1RJTUUgKyAxMDApXG5cblx0Ly8gVXBkYXRlIHVzZXIgc3RhdGVcblx0aWYgKHN0YXRlKSB7XG5cdFx0c3RhdGUuYWN0aXZpdGllcy5hZGQoJ3R5cGluZycpXG5cdFx0c3RhdGUuZGVib3VuY2UgPSBkZWJvdW5jZVxuXHRcdHN0YXRlLmxhc3RUeXBlZEF0ID0gRGF0ZS5ub3coKVxuXHRcdHJldHVyblxuXHR9IGVsc2Uge1xuXHRcdFVzZXJTdGF0dXNbZXZlbnQudXNlci5pZF0gPSB7XG5cdFx0XHRhY3Rpdml0aWVzOiBuZXcgU2V0PCdzcGVha2luZycgfCAndHlwaW5nJz4oKS5hZGQoJ3R5cGluZycpLFxuXHRcdFx0Y29udGV4dDogW10sXG5cdFx0XHRkZWJvdW5jZTogZGVib3VuY2UsXG5cdFx0XHRsYXN0VHlwZWRBdDogRGF0ZS5ub3coKVxuXHRcdH1cblx0fVxufVxuXG5pbnRlcmZhY2UgVXNlclN0YXRlIHtcblx0YWN0aXZpdGllczogU2V0PCdzcGVha2luZycgfCAndHlwaW5nJz5cblx0Y29udGV4dDogc3RyaW5nW11cblx0ZGVib3VuY2U6IE5vZGVKUy5UaW1lb3V0XG5cdGxhc3RUeXBlZEF0OiBudW1iZXJcbn1cbmNvbnN0IFVzZXJTdGF0dXM6IFJlY29yZDxzdHJpbmcsIFVzZXJTdGF0ZT4gPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkVXNlckZvbGxvd1VwKHVzZXJJZDogc3RyaW5nLCBtZXNzYWdlOiBNZXNzYWdlLCBtZXNzYWdlQ29udGVudDogc3RyaW5nKSB7XG5cdGNvbnN0IHN0YXRlID0gVXNlclN0YXR1c1t1c2VySWRdXG5cblx0Ly8gRG9uJ3QgYWRkIGZvbGxvdy11cHMgaWYgdGhlIHVzZXIgaXNuJ3QgdHlwaW5nXG5cdGlmICghc3RhdGU/LmFjdGl2aXRpZXM/LmhhcygndHlwaW5nJykpIHtcblx0XHRsb2dnZXIuZGVidWcoYFVzZXIgQCR7dXNlcklkfSBpc24ndCB0eXBpbmcsIGNhbid0IGFkZCBmb2xsb3ctdXBgKVxuXHRcdHJldHVyblxuXHR9XG5cblx0Ly8gQWRkIHRoZSBtZXNzYWdlIHRvIHRoZSB1c2VyJ3MgY29udGV4dFxuXHRzdGF0ZS5jb250ZXh0LnB1c2gobWVzc2FnZS5hdXRob3IudXNlcm5hbWUgKyAnOiAnICsgbWVzc2FnZUNvbnRlbnQpXG5cdGNsZWFyVXNlclR5cGluZyh1c2VySWQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclVzZXJUeXBpbmcodXNlcklkOiBzdHJpbmcpIHtcblx0Y29uc3Qgc3RhdGUgPSBVc2VyU3RhdHVzW3VzZXJJZF1cblx0aWYgKCFzdGF0ZSkge1xuXHRcdHJldHVyblxuXHR9XG5cblx0Y2xlYXJUaW1lb3V0KHN0YXRlLmRlYm91bmNlKVxuXHRzdGF0ZS5hY3Rpdml0aWVzLmRlbGV0ZSgndHlwaW5nJylcblx0bG9nZ2VyLmRlYnVnKGBDbGVhcmVkIHR5cGluZyBzdGF0ZSBmb3IgQCR7dXNlcklkfWApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VzZXJUeXBpbmcodXNlcklkOiBzdHJpbmcpIHtcblx0Y29uc3Qgc3RhdGUgPSBVc2VyU3RhdHVzW3VzZXJJZF1cblxuXHQvLyBObyBzdGF0ZSBtZWFucyB0aGUgdXNlciBpc24ndCB0eXBpbmdcblx0aWYgKCFzdGF0ZSkge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cblx0Ly8gTm8gYWN0aXZlIHR5cGluZyBtZWFucyB0aGUgdXNlciBpc24ndCB0eXBpbmdcblx0aWYgKCFzdGF0ZS5hY3Rpdml0aWVzLmhhcygndHlwaW5nJykpIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdC8vIE5vdCBoYXZpbmcgdHlwZWQgaW4gYSB3aGlsZSBtZWFucyB0aGUgdXNlciBpc24ndCB0eXBpbmdcblx0aWYgKERhdGUubm93KCkgLSBzdGF0ZS5sYXN0VHlwZWRBdCA+IERFQk9VTkNFX1RJTUUpIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWl0Rm9yVHlwaW5nKHVzZXJJZDogc3RyaW5nKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmdbXT4oKHJlc29sdmUpID0+IHtcblx0XHRjb25zdCBydW4gPSBhc3luYyAoKSA9PiB7XG5cdFx0XHQvLyBMb29wIHVudGlsIHRoZSB1c2VyIHN0b3BzIHR5cGluZ1xuXHRcdFx0d2hpbGUgKGlzVXNlclR5cGluZyh1c2VySWQpKSB7XG5cdFx0XHRcdGNvbnN0IHN0YXRlID0gVXNlclN0YXR1c1t1c2VySWRdXG5cblx0XHRcdFx0Ly8gRGVsYXkgYnkgdGhlIHJlbWFpbmluZyBkZWJvdW5jZSB0aW1lICh1cCB0byBtYXggaW4gY2FzZSBtZXNzYWdlIHdhcyBzZW50KVxuXHRcdFx0XHRjb25zdCByZW1haW5pbmcgPSBNYXRoLm1pbihERUJPVU5DRV9USU1FIC0gKERhdGUubm93KCkgLSBzdGF0ZS5sYXN0VHlwZWRBdCksIERFQk9VTkNFX01BWClcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKGBXYWl0aW5nIGZvciB1c2VyIEAke3VzZXJJZH0gdG8gc3RvcCB0eXBpbmcgKCR7cmVtYWluaW5nfW1zKWApXG5cdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJlbWFpbmluZykpXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgd2l0aCB0aGUgdXNlcidzIGNvbnRleHQgKHdoaWxlIGNsZWFyaW5nIGZvciBuZXh0IHRpbWUpXG5cdFx0XHRjb25zdCBzdGF0ZSA9IFVzZXJTdGF0dXNbdXNlcklkXVxuXHRcdFx0Y29uc3QgY29udGV4dCA9IHN0YXRlPy5jb250ZXh0ID8/IFtdXG5cdFx0XHRpZiAoc3RhdGUpIHtcblx0XHRcdFx0c3RhdGUuY29udGV4dCA9IFtdXG5cdFx0XHRcdGNsZWFyVXNlclR5cGluZyh1c2VySWQpXG5cdFx0XHR9XG5cdFx0XHRsb2dnZXIuZGVidWcoYFVzZXIgQCR7dXNlcklkfSBzdG9wcGVkIHR5cGluZy4gQ29udGV4dDpgLCBjb250ZXh0KVxuXHRcdFx0cmVzb2x2ZShjb250ZXh0KVxuXHRcdH1cblx0XHRydW4oKVxuXHR9KVxufVxuIl0sIm5hbWVzIjpbImlzUmVwbHlpbmdUb1VzZXIiLCJsb2dnZXIiLCJjbGllbnQiLCJERUJPVU5DRV9USU1FIiwiREVCT1VOQ0VfTUFYIiwiZXZlbnQiLCJ1c2VyIiwiaWQiLCJkZWJ1ZyIsInVzZXJuYW1lIiwic3RhdGUiLCJVc2VyU3RhdHVzIiwiZGVib3VuY2UiLCJjbGVhclRpbWVvdXQiLCJhY3Rpdml0aWVzIiwiaGFzIiwiY29udGV4dCIsInNldFRpbWVvdXQiLCJjbGVhclVzZXJUeXBpbmciLCJhZGQiLCJsYXN0VHlwZWRBdCIsIkRhdGUiLCJub3ciLCJTZXQiLCJhZGRVc2VyRm9sbG93VXAiLCJ1c2VySWQiLCJtZXNzYWdlIiwibWVzc2FnZUNvbnRlbnQiLCJwdXNoIiwiYXV0aG9yIiwiZGVsZXRlIiwiaXNVc2VyVHlwaW5nIiwid2FpdEZvclR5cGluZyIsIlByb21pc2UiLCJyZXNvbHZlIiwicnVuIiwicmVtYWluaW5nIiwiTWF0aCIsIm1pbiJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsZ0JBQWdCLFFBQVEscUNBQWM7QUFDL0MsU0FBU0MsTUFBTSxRQUFRLHlDQUFrQjtBQUN6QyxTQUFTQyxNQUFNLFFBQVEsVUFBUztBQUdoQyx5REFBeUQ7QUFDekQsTUFBTUMsZ0JBQWdCO0FBRXRCLCtEQUErRDtBQUMvRCxNQUFNQyxlQUFlO0FBRXJCOzs7Q0FHQyxHQUNELGVBQWUsQ0FBQSxDQUFDQyxRQUFrQjtJQUNqQyxNQUFNLEVBQUVDLEtBQUksRUFBRSxHQUFHRDtJQUVqQiwwQkFBMEI7SUFDMUIsSUFBSUMsS0FBS0MsRUFBRSxLQUFLTCxPQUFPSSxJQUFJLEVBQUVDLElBQUk7UUFDaEM7SUFDRCxDQUFDO0lBRUQsd0RBQXdEO0lBQ3hELElBQUksQ0FBQ1AsaUJBQWlCTSxLQUFLQyxFQUFFLEdBQUc7UUFDL0JOLE9BQU9PLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRUYsS0FBS0csUUFBUSxDQUFDLDBDQUEwQyxDQUFDO1FBQy9FO0lBQ0QsQ0FBQztJQUNEUixPQUFPTyxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUVGLEtBQUtHLFFBQVEsQ0FBQyxlQUFlLENBQUM7SUFFcEQsOEJBQThCO0lBQzlCLE1BQU1DLFFBQVFDLFVBQVUsQ0FBQ04sTUFBTUMsSUFBSSxDQUFDQyxFQUFFLENBQUM7SUFDdkMsSUFBSUcsT0FBT0UsVUFBVTtRQUNwQkMsYUFBYUgsTUFBTUUsUUFBUTtJQUM1QixDQUFDO0lBRUQsNENBQTRDO0lBQzVDLElBQUlGLFNBQVMsQ0FBQ0EsTUFBTUksVUFBVSxFQUFFQyxJQUFJLFdBQVc7UUFDOUNMLE1BQU1NLE9BQU8sR0FBRyxFQUFFO0lBQ25CLENBQUM7SUFFRCxxQkFBcUI7SUFDckIsTUFBTUos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